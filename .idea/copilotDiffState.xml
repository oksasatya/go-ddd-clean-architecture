<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="updatedContent" value="# syntax=docker/dockerfile:1&#10;&#10;# ---------- Build stage ----------&#10;FROM golang:1.24-bookworm AS builder&#10;WORKDIR /src&#10;&#10;# Enable static build for minimal final image&#10;ENV CGO_ENABLED=0 GOOS=linux GOARCH=amd64&#10;&#10;# Pre-cache deps&#10;COPY go.mod go.sum ./&#10;RUN --mount=type=cache,target=/go/pkg/mod \&#10;    go mod download&#10;&#10;# Copy the rest of the source&#10;COPY . .&#10;&#10;# Build the binary&#10;RUN --mount=type=cache,target=/root/.cache/go-build \&#10;    go build -ldflags=&quot;-s -w&quot; -o /out/server ./cmd&#10;&#10;# ---------- Runtime stage ----------&#10;FROM alpine:3.20&#10;&#10;# Install certificates and timezone data&#10;RUN apk add --no-cache ca-certificates tzdata&#10;&#10;WORKDIR /app&#10;&#10;# Copy binary and runtime assets (migrations)&#10;COPY --from=builder /out/server /app/server&#10;COPY db/migrations /app/db/migrations&#10;&#10;# Non-root user&#10;RUN addgroup -S app &amp;&amp; adduser -S -G app appuser&#10;USER appuser&#10;&#10;ENV GIN_MODE=release&#10;# Railway sets PORT; ensure default for local run&#10;ENV PORT=8080&#10;&#10;EXPOSE 8080&#10;&#10;# Start the service&#10;CMD [&quot;/app/server&quot;]&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Go DDD Boilerplate (Gin, Postgres, Redis, GCS, JWT)&#10;&#10;Production-ready Go 1.24.x boilerplate following DDD/Clean Architecture.&#10;&#10;Stack:&#10;- Gin HTTP framework&#10;- PostgreSQL (pgx) + golang-migrate&#10;- Redis (go-redis)&#10;- Google Cloud Storage (GCS)&#10;- JWT (access 1h, refresh 168h)&#10;- sqlc (optional codegen)&#10;- Logrus&#10;- CORS middleware (gin-contrib/cors)&#10;- .env loader (joho/godotenv)&#10;&#10;API base path: /api&#10;&#10;## Architecture &amp; folder structure&#10;```&#10;cmd/&#10;  main.go                # app entrypoint (DI, registry wiring, graceful shutdown)&#10;  seed/main.go           # sample seeder (1 demo user)&#10;configs/&#10;  config.go              # env config, DSN, CORS origins&#10;internal/&#10;  domain/                # domain layer (entities, repositories)&#10;    user/&#10;      entity.go&#10;      repository.go&#10;  application/           # use cases/services&#10;    user/&#10;      service.go&#10;  infrastructure/        # external adapters (db/cache/etc)&#10;    postgres/&#10;      pool.go&#10;      repository_user.go&#10;  interface/             # delivery layer (http handlers, middleware)&#10;    http/&#10;      user_handler.go&#10;    middleware/&#10;      jwt.go&#10;      request_id.go&#10;  router/&#10;    module.go            # Module interface&#10;    registry.go          # Registry that groups /api and mounts modules&#10;    modules/&#10;      user/&#10;        module.go        # User module routing (public + protected)&#10;db/&#10;  migrations/            # SQL migrations for golang-migrate&#10;    000001_init_users.sql&#10;  query/                 # sqlc queries (optional)&#10;    users.sql&#10;pkg/&#10;  helpers/&#10;    gcs.go               # GCS client + upload helper&#10;    jwt.go               # JWT manager&#10;    logger.go            # Logrus helper&#10;    password.go          # bcrypt helpers&#10;    redis.go             # Redis helpers (JSON)&#10;    response.go          # generic API response (Success/Error)&#10;sqlc.yaml                # sqlc configuration (optional)&#10;Makefile                 # dev scripts: migrate, seed, run, etc.&#10;Dockerfile               # multi-stage build (linux/amd64)&#10;.env                     # local development variables&#10;```&#10;&#10;## Environment variables (.env)&#10;Example .env for local development:&#10;```&#10;APP_NAME=go-ddd-boilerplate&#10;APP_ENV=development&#10;PORT=8080&#10;GIN_MODE=release&#10;COOKIE_DOMAIN=localhost&#10;COOKIE_SECURE=false&#10;&#10;DB_HOST=localhost&#10;DB_PORT=5432&#10;DB_USER=postgres&#10;DB_PASSWORD=postgres&#10;DB_NAME=appdb&#10;DB_SSLMODE=disable&#10;DB_MAX_CONNS=10&#10;DB_MIN_CONNS=2&#10;DB_MAX_CONN_LIFETIME=1h&#10;&#10;REDIS_ADDR=localhost:6379&#10;REDIS_PASSWORD=&#10;REDIS_DB=0&#10;&#10;GCS_BUCKET=&#10;GCS_CREDENTIALS_JSON=&#10;&#10;JWT_ACCESS_SECRET=devaccesssecret&#10;JWT_REFRESH_SECRET=devrefreshsecret&#10;JWT_ACCESS_TTL=1h&#10;JWT_REFRESH_TTL=168h&#10;&#10;MIGRATIONS_DIR=db/migrations&#10;CORS_ALLOWED_ORIGINS=http://localhost:3000&#10;```&#10;&#10;## Run locally&#10;1) Dependencies&#10;- Go 1.24.x&#10;- Postgres, Redis running locally&#10;- golang-migrate CLI (https://github.com/golang-migrate/migrate)&#10;&#10;2) Install modules&#10;```&#10;make tidy&#10;```&#10;&#10;3) Run migrations&#10;```&#10;make migrate-up&#10;```&#10;&#10;4) Seed a demo user&#10;```&#10;make seed&#10;```&#10;This creates or upserts a user: demo@example.com with password: password&#10;&#10;5) Start the service&#10;```&#10;make run&#10;```&#10;Server listens on :$PORT (default 8080).&#10;&#10;## API&#10;- POST /api/login&#10;- POST /api/refresh&#10;- POST /api/logout (auth)&#10;- GET  /api/profile (auth)&#10;- PUT  /api/profile (auth)&#10;&#10;JWT tokens are set as httpOnly cookies: access_token, refresh_token.&#10;All responses include request_id and timestamp.&#10;&#10;## SQLC (optional)&#10;- Define queries in db/query/*.sql&#10;- Configure in sqlc.yaml&#10;- Generate:&#10;```&#10;make sqlc-generate&#10;```&#10;&#10;## Migrations&#10;- Up: `make migrate-up`&#10;- Down (1 step): `make migrate-down`&#10;- Drop all: `make migrate-drop`&#10;&#10;The DSN is composed from .env (DB_*).&#10;&#10;## Docker (Railway-ready)&#10;Build linux/amd64 image:&#10;```&#10;docker build --platform linux/amd64 -t your-org/go-ddd-boilerplate:latest .&#10;```&#10;Run:&#10;```&#10;docker run --rm -p 8080:8080 --env-file .env your-org/go-ddd-boilerplate:latest&#10;```&#10;&#10;## Notes&#10;- CORS is configurable via CORS_ALLOWED_ORIGINS (comma-separated).&#10;- RequestIDMiddleware injects request_id for every request; response helpers include it.&#10;- The service includes an example GCS upload method in the User service if needed (not wired to a public endpoint by default).&#10;&#10;" />
              <option name="updatedContent" value="# Go DDD Boilerplate (Gin, Postgres, Redis, GCS, JWT)&#13;&#10;&#13;&#10;Production-ready Go boilerplate with DDD/Clean Architecture and pragmatic defaults.&#13;&#10;&#13;&#10;Stack&#13;&#10;- Gin HTTP framework&#13;&#10;- PostgreSQL (pgx) + golang-migrate (runs at startup)&#13;&#10;- Redis (go-redis) for sessions/caching + rate limiting&#13;&#10;- Google Cloud Storage (optional)&#13;&#10;- JWT (access/refresh cookies)&#13;&#10;- Logrus, CORS, Makefile helpers&#13;&#10;&#13;&#10;API base path: /api&#13;&#10;&#13;&#10;Architecture &amp; folders&#13;&#10;```&#13;&#10;cmd/&#13;&#10;  main.go                 # app entrypoint, DI, migrations, graceful shutdown&#13;&#10;  seed/main.go            # simple seeder (demo user)&#13;&#10;configs/&#13;&#10;  config.go               # env config, DSN helpers, CORS origins&#13;&#10;internal/&#13;&#10;  domain/&#13;&#10;    entity/&#13;&#10;      user_entity.go&#13;&#10;    repository/&#13;&#10;      user_repository.go&#13;&#10;  application/&#13;&#10;    user_service.go       # business logic/use-cases&#13;&#10;  infrastructure/&#13;&#10;    postgres/&#13;&#10;      pool.go&#13;&#10;      user_repository_impl.go&#13;&#10;  interface/&#13;&#10;    http/&#13;&#10;      user_handler.go&#13;&#10;    middleware/&#13;&#10;      jwt.go&#13;&#10;      rate_limit.go&#13;&#10;      request_id.go&#13;&#10;  router/&#13;&#10;    init.go               # wire modules with container singletons&#13;&#10;    module.go             # Registry module interface&#13;&#10;    registry.go           # groups /api and mounts modules&#13;&#10;    modules/&#13;&#10;      user/&#13;&#10;        module.go         # public + protected routes (JWT + rate limits)&#13;&#10;db/&#13;&#10;  migrations/&#13;&#10;    000001_init_users.sql&#13;&#10;  query/&#13;&#10;    users.sql             # optional sqlc&#13;&#10;pkg/&#13;&#10;  helpers/&#13;&#10;    gcs.go, jwt.go, logger.go, password.go, redis.go, response.go&#13;&#10;Makefile&#13;&#10;sqlc.yaml&#13;&#10;```&#13;&#10;&#13;&#10;Environment variables (.env)&#13;&#10;```&#13;&#10;APP_NAME=go-ddd-boilerplate&#13;&#10;APP_ENV=development&#13;&#10;PORT=8080&#13;&#10;GIN_MODE=release&#13;&#10;COOKIE_DOMAIN=localhost&#13;&#10;COOKIE_SECURE=false&#13;&#10;&#13;&#10;DB_HOST=localhost&#13;&#10;DB_PORT=5432&#13;&#10;DB_USER=postgres&#13;&#10;DB_PASSWORD=postgres&#13;&#10;DB_NAME=appdb&#13;&#10;DB_SSLMODE=disable&#13;&#10;DB_MAX_CONNS=10&#13;&#10;DB_MIN_CONNS=2&#13;&#10;DB_MAX_CONN_LIFETIME=1h&#13;&#10;&#13;&#10;REDIS_ADDR=localhost:6379&#13;&#10;REDIS_PASSWORD=&#13;&#10;REDIS_DB=0&#13;&#10;&#13;&#10;GCS_BUCKET=&#13;&#10;GCS_CREDENTIALS_JSON=&#13;&#10;&#13;&#10;JWT_ACCESS_SECRET=devaccesssecret&#13;&#10;JWT_REFRESH_SECRET=devrefreshsecret&#13;&#10;JWT_ACCESS_TTL=1h&#13;&#10;JWT_REFRESH_TTL=168h&#13;&#10;&#13;&#10;MIGRATIONS_DIR=db/migrations&#13;&#10;CORS_ALLOWED_ORIGINS=http://localhost:3000&#13;&#10;```&#13;&#10;&#13;&#10;Run locally&#13;&#10;- Prereq: Go 1.22+ (or latest), Postgres, Redis, golang-migrate CLI&#13;&#10;- Install modules: make tidy&#13;&#10;- Run migrations: make migrate-up&#13;&#10;- Seed demo user: make seed (email: demo@example.com, password: password)&#13;&#10;- Start API: make run (listens on :$PORT)&#13;&#10;&#13;&#10;API overview&#13;&#10;- POST /api/login (rate-limited 5/min per IP+path)&#13;&#10;- POST /api/refresh (rate-limited 20/min per IP+path)&#13;&#10;- POST /api/logout (JWT required; protected group limited 120/min per IP)&#13;&#10;- GET  /api/profile (JWT)&#13;&#10;- PUT  /api/profile (JWT)&#13;&#10;&#13;&#10;Notes&#13;&#10;- JWT tokens are httpOnly cookies: access_token, refresh_token.&#13;&#10;- Responses include a request_id and timestamp. RequestID middleware sets request_id.&#13;&#10;- Redis must be available for rate limiting. On Redis errors, middleware fails open.&#13;&#10;&#13;&#10;SQLC (optional)&#13;&#10;- Define queries in db/query/*.sql&#13;&#10;- Generate with make sqlc-generate&#13;&#10;&#13;&#10;Migrations&#13;&#10;- Up: make migrate-up&#13;&#10;- Down (1): make migrate-down&#13;&#10;- Drop all: make migrate-drop&#13;&#10;&#13;&#10;Docker (local)&#13;&#10;- Build: docker build --platform linux/amd64 -t boilerplate-go-pgsql:latest .&#13;&#10;- Run: docker run --rm -p 8080:8080 --env-file .env boilerplate-go-pgsql:latest&#13;&#10;&#13;&#10;Deploy to Railway&#13;&#10;- Create a new Railway project.&#13;&#10;- Add services: PostgreSQL and Redis plugins. Copy their connection details.&#13;&#10;- Deploy from GitHub using the Dockerfile in this repo.&#13;&#10;- Set environment variables in Railway:&#13;&#10;  - PORT: 8080 (Railway also injects PORT; app reads it)&#13;&#10;  - DB_HOST, DB_PORT, DB_USER, DB_PASSWORD, DB_NAME from the Postgres plugin&#13;&#10;  - DB_SSLMODE=require (Railway Postgres enforces TLS)&#13;&#10;  - REDIS_ADDR as host:port from the Redis plugin, REDIS_PASSWORD if provided, REDIS_DB=0&#13;&#10;  - JWT_ACCESS_SECRET, JWT_REFRESH_SECRET (generate strong secrets)&#13;&#10;  - CORS_ALLOWED_ORIGINS to your frontend URL (e.g., https://your-app.vercel.app)&#13;&#10;  - COOKIE_DOMAIN to your domain; set COOKIE_SECURE=true for HTTPS&#13;&#10;  - MIGRATIONS_DIR=db/migrations (default)&#13;&#10;- Redeploy; the app runs migrations at startup and serves on /api.&#13;&#10;&#13;&#10;Troubleshooting&#13;&#10;- 429 Too Many Requests: hit rate limits; check Retry-After header.&#13;&#10;- Invalid tokens: verify JWT secrets match across deployments.&#13;&#10;- SSL errors to Postgres on Railway: ensure DB_SSLMODE=require.&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/application/user/service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/application/user/service.go" />
              <option name="originalContent" value="package userapp&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;domain &quot;boilerplate-go-pgsql/internal/domain/user&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;var (&#10;&#9;ErrInvalidCredentials = errors.New(&quot;invalid credentials&quot;)&#10;&#9;ErrUserNotFound       = errors.New(&quot;user not found&quot;)&#10;)&#10;&#10;type Service struct {&#10;&#9;Repo domain.Repository&#10;&#9;JWT  *helpers.JWTManager&#10;}&#10;&#10;func NewService(repo domain.Repository, jwt *helpers.JWTManager) *Service {&#10;&#9;return &amp;Service{Repo: repo, JWT: jwt}&#10;}&#10;&#10;type LoginResponse struct {&#10;&#9;UserID string `json:&quot;user_id&quot;`&#10;&#9;Email  string `json:&quot;email&quot;`&#10;&#9;Name   string `json:&quot;name&quot;`&#10;}&#10;&#10;func (s *Service) Login(email, password string) (*LoginResponse, string, time.Time, string, time.Time, error) {&#10;&#9;u, err := s.Repo.GetByEmail(email)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;if !helpers.CompareHashAndPassword(u.Password, password) {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;return &amp;LoginResponse{UserID: u.ID, Email: u.Email, Name: u.Name}, access, aexp, refresh, rexp, nil&#10;}&#10;&#10;func (s *Service) Refresh(refreshToken string) (string, time.Time, string, time.Time, string, error) {&#10;&#9;claims, err := s.JWT.ParseRefreshToken(refreshToken)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;// ensure user still exists&#10;&#9;u, err := s.Repo.GetByID(claims.UserID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;return access, aexp, refresh, rexp, u.ID, nil&#10;}&#10;&#10;func (s *Service) GetProfile(userID string) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;type UpdateProfileInput struct {&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;}&#10;&#10;func (s *Service) UpdateProfile(userID string, in UpdateProfileInput) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;if in.Name != &quot;&quot; {&#10;&#9;&#9;u.Name = in.Name&#10;&#9;}&#10;&#9;if in.AvatarURL != &quot;&quot; {&#10;&#9;&#9;u.AvatarURL = in.AvatarURL&#10;&#9;}&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;" />
              <option name="updatedContent" value="package userapp&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;cloud.google.com/go/storage&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;domain &quot;boilerplate-go-pgsql/internal/domain/user&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;var (&#10;&#9;ErrInvalidCredentials = errors.New(&quot;invalid credentials&quot;)&#10;&#9;ErrUserNotFound       = errors.New(&quot;user not found&quot;)&#10;)&#10;&#10;type Service struct {&#10;&#9;Repo      domain.Repository&#10;&#9;JWT       *helpers.JWTManager&#10;&#9;GCS       *storage.Client&#10;&#9;GCSBucket string&#10;&#9;Redis     *redis.Client&#10;&#9;Logger    *logrus.Logger&#10;}&#10;&#10;func NewService(repo domain.Repository, jwt *helpers.JWTManager, gcs *storage.Client, gcsBucket string, rdb *redis.Client, logger *logrus.Logger) *Service {&#10;&#9;return &amp;Service{Repo: repo, JWT: jwt, GCS: gcs, GCSBucket: gcsBucket, Redis: rdb, Logger: logger}&#10;}&#10;&#10;type LoginResponse struct {&#10;&#9;UserID string `json:&quot;user_id&quot;`&#10;&#9;Email  string `json:&quot;email&quot;`&#10;&#9;Name   string `json:&quot;name&quot;`&#10;}&#10;&#10;func (s *Service) Login(email, password string) (*LoginResponse, string, time.Time, string, time.Time, error) {&#10;&#9;u, err := s.Repo.GetByEmail(email)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;if !helpers.CompareHashAndPassword(u.Password, password) {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;return &amp;LoginResponse{UserID: u.ID, Email: u.Email, Name: u.Name}, access, aexp, refresh, rexp, nil&#10;}&#10;&#10;func (s *Service) Refresh(refreshToken string) (string, time.Time, string, time.Time, string, error) {&#10;&#9;claims, err := s.JWT.ParseRefreshToken(refreshToken)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;// ensure user still exists&#10;&#9;u, err := s.Repo.GetByID(claims.UserID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;return access, aexp, refresh, rexp, u.ID, nil&#10;}&#10;&#10;func (s *Service) GetProfile(userID string) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;type UpdateProfileInput struct {&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;}&#10;&#10;func (s *Service) UpdateProfile(userID string, in UpdateProfileInput) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;if in.Name != &quot;&quot; {&#10;&#9;&#9;u.Name = in.Name&#10;&#9;}&#10;&#9;if in.AvatarURL != &quot;&quot; {&#10;&#9;&#9;u.AvatarURL = in.AvatarURL&#10;&#9;}&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;// UploadAvatar demonstrates uploading an avatar to GCS from a reader and updating profile&#10;func (s *Service) UploadAvatar(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, ErrUserNotFound&#10;&#9;}&#10;&#9;url, err := s.uploadImageToGCS(ctx, userID, r, filename, contentType)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;u.AvatarURL = url&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;// cache meta in redis (optional)&#10;&#9;meta := map[string]any{&quot;user_id&quot;: userID, &quot;avatar_url&quot;: url, &quot;updated_at&quot;: time.Now()}&#10;&#9;_ = helpers.RedisSetJSON(ctx, s.Redis, &quot;user:avatar:&quot;+userID, meta, 24*time.Hour)&#10;&#9;return url, nil&#10;}&#10;&#10;func (s *Service) uploadImageToGCS(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;if s.GCS == nil || s.GCSBucket == &quot;&quot; {&#10;&#9;&#9;return &quot;&quot;, errors.New(&quot;gcs not configured&quot;)&#10;&#9;}&#10;&#9;id := uuid.NewString()&#10;&#9;ext := strings.ToLower(filepath.Ext(filename))&#10;&#9;objectPath := filepath.ToSlash(filepath.Join(&quot;avatars&quot;, userID, id+ext))&#10;&#9;return helpers.UploadImageToGCS(ctx, s.GCS, s.GCSBucket, objectPath, contentType, r)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/domain/user/entity.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/domain/user/entity.go" />
              <option name="originalContent" value="package user&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// User is the aggregate root for user domain&#10;// Passwords are stored as bcrypt hashes&#10;//&#10;// In a real-world app, prefer value objects for Email, etc.&#10;type User struct {&#10;&#9;ID           string&#10;&#9;Email        string&#10;&#9;PasswordHash string&#10;&#9;Name         string&#10;&#9;AvatarURL    string&#10;&#9;CreatedAt    time.Time&#10;&#9;UpdatedAt    time.Time&#10;}&#10;" />
              <option name="updatedContent" value="package user&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// User is the aggregate root for user domain&#10;// Passwords are stored as bcrypt hashes in Password field&#10;//&#10;// In a real-world app, prefer value objects for Email, etc.&#10;type User struct {&#10;&#9;ID        string&#10;&#9;Email     string&#10;&#9;Password  string&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;&#9;CreatedAt time.Time&#10;&#9;UpdatedAt time.Time&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/domain/user/repository.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/domain/user/repository.go" />
              <option name="updatedContent" value="package user&#10;&#10;// Repository abstracts persistence for User aggregate&#10;// This lives in the domain layer to decouple application/business logic from infrastructure.&#10;type Repository interface {&#10;&#9;Create(u *User) error&#10;&#9;GetByID(id string) (*User, error)&#10;&#9;GetByEmail(email string) (*User, error)&#10;&#9;Update(u *User) error&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/infrastructure/postgres/user_repository_impl.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/infrastructure/postgres/user_repository_impl.go" />
              <option name="originalContent" value="package postgres&#10;&#10;import (&#10;&#9;&quot;boilerplate-go-pgsql/internal/domain/repository&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/jackc/pgx/v5&quot;&#10;&#9;&quot;github.com/jackc/pgx/v5/pgxpool&quot;&#10;&#10;&#9;&quot;boilerplate-go-pgsql/internal/domain/entity&quot;&#10;)&#10;&#10;var (&#10;&#9;errNotFound = errors.New(&quot;not found&quot;)&#10;)&#10;&#10;type UserRepo struct {&#10;&#9;pool *pgxpool.Pool&#10;}&#10;&#10;func NewUserRepo(pool *pgxpool.Pool) *UserRepo {&#10;&#9;return &amp;UserRepo{pool: pool}&#10;}&#10;&#10;func (r *UserRepo) Create(u *entity.User) error {&#10;&#9;ctx := context.Background()&#10;&#9;row := r.pool.QueryRow(ctx, `&#10;&#9;&#9;INSERT INTO users (email, password_hash, name, avatar_url)&#10;&#9;&#9;VALUES ($1, $2, $3, $4)&#10;&#9;&#9;RETURNING id, created_at, updated_at&#10;&#9;`, u.Email, u.Password, u.Name, u.AvatarURL)&#10;&#10;&#9;return row.Scan(&amp;u.ID, &amp;u.CreatedAt, &amp;u.UpdatedAt)&#10;}&#10;&#10;func (r *UserRepo) GetByID(id string) (*entity.User, error) {&#10;&#9;ctx := context.Background()&#10;&#9;u := &amp;entity.User{}&#10;&#10;&#9;row := r.pool.QueryRow(ctx, `&#10;&#9;&#9;SELECT id, email, password_hash, name, avatar_url, created_at, updated_at&#10;&#9;&#9;FROM users&#10;&#9;&#9;WHERE id = $1&#10;&#9;`, id)&#10;&#10;&#9;if err := row.Scan(&amp;u.ID, &amp;u.Email, &amp;u.Password, &amp;u.Name, &amp;u.AvatarURL,&#10;&#9;&#9;&amp;u.CreatedAt, &amp;u.UpdatedAt); err != nil {&#10;&#9;&#9;if errors.Is(err, pgx.ErrNoRows) {&#10;&#9;&#9;&#9;return nil, errNotFound&#10;&#9;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return u, nil&#10;}&#10;&#10;func (r *UserRepo) GetByEmail(email string) (*entity.User, error) {&#10;&#9;ctx := context.Background()&#10;&#9;u := &amp;entity.User{}&#10;&#10;&#9;row := r.pool.QueryRow(ctx, `&#10;&#9;&#9;SELECT id, email, password_hash, name, avatar_url, created_at, updated_at&#10;&#9;&#9;FROM users&#10;&#9;&#9;WHERE email = $1&#10;&#9;`, email)&#10;&#10;&#9;if err := row.Scan(&amp;u.ID, &amp;u.Email, &amp;u.Password, &amp;u.Name, &amp;u.AvatarURL,&#10;&#9;&#9;&amp;u.CreatedAt, &amp;u.UpdatedAt); err != nil {&#10;&#9;&#9;if errors.Is(err, pgx.ErrNoRows) {&#10;&#9;&#9;&#9;return nil, errNotFound&#10;&#9;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return u, nil&#10;}&#10;&#10;func (r *UserRepo) Update(u *entity.User) error {&#10;&#9;ctx := context.Background()&#10;&#9;u.UpdatedAt = time.Now()&#10;&#10;&#9;res, err := r.pool.Exec(ctx, `&#10;&#9;&#9;UPDATE users&#10;&#9;&#9;SET email = $1, password_hash = $2, name = $3, avatar_url = $4, updated_at = $5&#10;&#9;&#9;WHERE id = $6&#10;&#9;`, u.Email, u.Password, u.Name, u.AvatarURL, u.UpdatedAt, u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if res.RowsAffected() == 0 {&#10;&#9;&#9;return errNotFound&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;var _ UserRepo = (*repository.UserRepository)(nil)&#10;" />
              <option name="updatedContent" value="package postgres&#10;&#10;import (&#10;&#9;&quot;boilerplate-go-pgsql/internal/domain/repository&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/jackc/pgx/v5&quot;&#10;&#9;&quot;github.com/jackc/pgx/v5/pgxpool&quot;&#10;&#10;&#9;&quot;boilerplate-go-pgsql/internal/domain/entity&quot;&#10;)&#10;&#10;var (&#10;&#9;errNotFound = errors.New(&quot;not found&quot;)&#10;)&#10;&#10;type UserRepo struct {&#10;&#9;pool *pgxpool.Pool&#10;}&#10;&#10;func NewUserRepo(pool *pgxpool.Pool) *UserRepo {&#10;&#9;return &amp;UserRepo{pool: pool}&#10;}&#10;&#10;func (r *UserRepo) Create(u *entity.User) error {&#10;&#9;ctx := context.Background()&#10;&#9;row := r.pool.QueryRow(ctx, `&#10;&#9;&#9;INSERT INTO users (email, password_hash, name, avatar_url)&#10;&#9;&#9;VALUES ($1, $2, $3, $4)&#10;&#9;&#9;RETURNING id, created_at, updated_at&#10;&#9;`, u.Email, u.Password, u.Name, u.AvatarURL)&#10;&#10;&#9;return row.Scan(&amp;u.ID, &amp;u.CreatedAt, &amp;u.UpdatedAt)&#10;}&#10;&#10;func (r *UserRepo) GetByID(id string) (*entity.User, error) {&#10;&#9;ctx := context.Background()&#10;&#9;u := &amp;entity.User{}&#10;&#10;&#9;row := r.pool.QueryRow(ctx, `&#10;&#9;&#9;SELECT id, email, password_hash, name, avatar_url, created_at, updated_at&#10;&#9;&#9;FROM users&#10;&#9;&#9;WHERE id = $1&#10;&#9;`, id)&#10;&#10;&#9;if err := row.Scan(&amp;u.ID, &amp;u.Email, &amp;u.Password, &amp;u.Name, &amp;u.AvatarURL,&#10;&#9;&#9;&amp;u.CreatedAt, &amp;u.UpdatedAt); err != nil {&#10;&#9;&#9;if errors.Is(err, pgx.ErrNoRows) {&#10;&#9;&#9;&#9;return nil, errNotFound&#10;&#9;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return u, nil&#10;}&#10;&#10;func (r *UserRepo) GetByEmail(email string) (*entity.User, error) {&#10;&#9;ctx := context.Background()&#10;&#9;u := &amp;entity.User{}&#10;&#10;&#9;row := r.pool.QueryRow(ctx, `&#10;&#9;&#9;SELECT id, email, password_hash, name, avatar_url, created_at, updated_at&#10;&#9;&#9;FROM users&#10;&#9;&#9;WHERE email = $1&#10;&#9;`, email)&#10;&#10;&#9;if err := row.Scan(&amp;u.ID, &amp;u.Email, &amp;u.Password, &amp;u.Name, &amp;u.AvatarURL,&#10;&#9;&#9;&amp;u.CreatedAt, &amp;u.UpdatedAt); err != nil {&#10;&#9;&#9;if errors.Is(err, pgx.ErrNoRows) {&#10;&#9;&#9;&#9;return nil, errNotFound&#10;&#9;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return u, nil&#10;}&#10;&#10;func (r *UserRepo) Update(u *entity.User) error {&#10;&#9;ctx := context.Background()&#10;&#9;u.UpdatedAt = time.Now()&#10;&#10;&#9;res, err := r.pool.Exec(ctx, `&#10;&#9;&#9;UPDATE users&#10;&#9;&#9;SET email = $1, password_hash = $2, name = $3, avatar_url = $4, updated_at = $5&#10;&#9;&#9;WHERE id = $6&#10;&#9;`, u.Email, u.Password, u.Name, u.AvatarURL, u.UpdatedAt, u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if res.RowsAffected() == 0 {&#10;&#9;&#9;return errNotFound&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;var _ repository.UserRepository = (*UserRepo)(nil)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/interface/http/image_handler.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/interface/http/image_handler.go" />
              <option name="updatedContent" value="package handlers&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;mime/multipart&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;cloud.google.com/go/storage&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;type ImageHandler struct {&#10;&#9;GCS    *storage.Client&#10;&#9;Bucket string&#10;&#9;Redis  *redis.Client&#10;&#9;Logger *logrus.Logger&#10;}&#10;&#10;func NewImageHandler(gcs *storage.Client, bucket string, rdb *redis.Client, logger *logrus.Logger) *ImageHandler {&#10;&#9;return &amp;ImageHandler{GCS: gcs, Bucket: bucket, Redis: rdb, Logger: logger}&#10;}&#10;&#10;type ImageMeta struct {&#10;&#9;ID          string    `json:&quot;id&quot;`&#10;&#9;URL         string    `json:&quot;url&quot;`&#10;&#9;ContentType string    `json:&quot;content_type&quot;`&#10;&#9;UploaderID  string    `json:&quot;uploader_id&quot;`&#10;&#9;CreatedAt   time.Time `json:&quot;created_at&quot;`&#10;}&#10;&#10;func (h *ImageHandler) Upload(c *gin.Context) {&#10;&#9;uid := c.GetString(&quot;userID&quot;)&#10;&#9;file, header, err := c.Request.FormFile(&quot;file&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusBadRequest, &quot;file is required&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer file.Close()&#10;&#10;&#9;contentType := sniffContentType(header)&#10;&#9;id := uuid.NewString()&#10;&#9;ext := strings.ToLower(filepath.Ext(header.Filename))&#10;&#9;objectPath := fmt.Sprintf(&quot;uploads/%s/%s%s&quot;, uid, id, ext)&#10;&#10;&#9;url, err := helpers.UploadObject(c.Request.Context(), h.GCS, h.Bucket, objectPath, contentType, file)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusInternalServerError, &quot;upload failed&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;meta := &amp;ImageMeta{ID: id, URL: url, ContentType: contentType, UploaderID: uid, CreatedAt: time.Now()}&#10;&#9;_ = helpers.RedisSetJSON(c.Request.Context(), h.Redis, imageKey(id), meta, 24*time.Hour)&#10;&#9;c.JSON(http.StatusOK, helpers.APIResponse(meta, &quot;uploaded&quot;))&#10;}&#10;&#10;func (h *ImageHandler) Get(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var meta ImageMeta&#10;&#9;found, err := helpers.RedisGetJSON(c.Request.Context(), h.Redis, imageKey(id), &amp;meta)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusInternalServerError, &quot;cache error&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;if !found {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusNotFound, &quot;image not found&quot;, nil)&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;c.JSON(http.StatusOK, helpers.APIResponse(meta, &quot;ok&quot;))&#10;}&#10;&#10;func sniffContentType(h *multipart.FileHeader) string {&#10;&#9;if h.Header.Get(&quot;Content-Type&quot;) != &quot;&quot; {&#10;&#9;&#9;return h.Header.Get(&quot;Content-Type&quot;)&#10;&#9;}&#10;&#9;return &quot;application/octet-stream&quot;&#10;}&#10;&#10;func imageKey(id string) string { return &quot;image:&quot; + id }&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/interface/middleware/rate_limit.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/interface/middleware/rate_limit.go" />
              <option name="originalContent" value="package middleware&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// KeyFunc builds a rate-limit key from the request&#10;// Example: combine client IP and route path for more granular limiting&#10; type KeyFunc func(c *gin.Context) string&#10;&#10;// KeyByIP returns a key function that limits by client IP only&#10;func KeyByIP() KeyFunc {&#10;&#9;return func(c *gin.Context) string {&#10;&#9;&#9;ip := c.ClientIP()&#10;&#9;&#9;if ip == &quot;&quot; {&#10;&#9;&#9;&#9;ip = &quot;unknown&quot;&#10;&#9;&#9;}&#10;&#9;&#9;return &quot;rl:ip:&quot; + ip&#10;&#9;}&#10;}&#10;&#10;// KeyByIPAndPath returns a key function that limits by client IP and request path&#10;func KeyByIPAndPath() KeyFunc {&#10;&#9;return func(c *gin.Context) string {&#10;&#9;&#9;ip := c.ClientIP()&#10;&#9;&#9;if ip == &quot;&quot; {&#10;&#9;&#9;&#9;ip = &quot;unknown&quot;&#10;&#9;&#9;}&#10;&#9;&#9;return &quot;rl:path:&quot; + c.FullPath() + &quot;:ip:&quot; + ip&#10;&#9;}&#10;}&#10;&#10;// RateLimit creates a Gin middleware that limits requests using Redis as a shared counter.&#10;// - rdb: Redis client&#10;// - max: maximum number of requests allowed within the window&#10;// - window: time window for the limit&#10;// - keyFn: function to construct a redis key for the caller&#10;func RateLimit(rdb *redis.Client, max int, window time.Duration, keyFn KeyFunc) gin.HandlerFunc {&#10;&#9;if rdb == nil || max &lt;= 0 || window &lt;= 0 || keyFn == nil {&#10;&#9;&#9;// No-op middleware if misconfigured&#10;&#9;&#9;return func(c *gin.Context) { c.Next() }&#10;&#9;}&#10;&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;ctx := c.Request.Context()&#10;&#9;&#9;key := keyFn(c)&#10;&#10;&#9;&#9;// INCR the counter and set expiry on first hit&#10;&#9;&#9;count, err := rdb.Incr(ctx, key).Result()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;// On Redis error, fail open&#10;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;if count == 1 {&#10;&#9;&#9;&#9;_ = rdb.Expire(ctx, key, window).Err()&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if int(count) &gt; max {&#10;&#9;&#9;&#9;// Optionally set Retry-After header to remaining window&#10;&#9;&#9;&#9;ttl, _ := rdb.TTL(ctx, key).Result()&#10;&#9;&#9;&#9;if ttl &gt; 0 {&#10;&#9;&#9;&#9;&#9;c.Header(&quot;Retry-After&quot;, strconv.Itoa(int(ttl.Seconds())))&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;resp := helpers.Error[any](c, http.StatusTooManyRequests, &quot;rate limit exceeded&quot;, nil)&#10;&#9;&#9;&#9;c.AbortWithStatusJSON(resp.Status, resp)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Continue&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package middleware&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// KeyFunc builds a rate-limit key from the request&#10;// Example: combine client IP and route path for more granular limiting&#10;type KeyFunc func(c *gin.Context) string&#10;&#10;// KeyByIP returns a key function that limits by client IP only&#10;func KeyByIP() KeyFunc {&#10;&#9;return func(c *gin.Context) string {&#10;&#9;&#9;ip := c.ClientIP()&#10;&#9;&#9;if ip == &quot;&quot; {&#10;&#9;&#9;&#9;ip = &quot;unknown&quot;&#10;&#9;&#9;}&#10;&#9;&#9;return &quot;rl:ip:&quot; + ip&#10;&#9;}&#10;}&#10;&#10;// KeyByIPAndPath returns a key function that limits by client IP and request path&#10;func KeyByIPAndPath() KeyFunc {&#10;&#9;return func(c *gin.Context) string {&#10;&#9;&#9;ip := c.ClientIP()&#10;&#9;&#9;if ip == &quot;&quot; {&#10;&#9;&#9;&#9;ip = &quot;unknown&quot;&#10;&#9;&#9;}&#10;&#9;&#9;return &quot;rl:path:&quot; + c.FullPath() + &quot;:ip:&quot; + ip&#10;&#9;}&#10;}&#10;&#10;// RateLimit creates a Gin middleware that limits requests using Redis as a shared counter.&#10;// - rdb: Redis client&#10;// - max: maximum number of requests allowed within the window&#10;// - window: time window for the limit&#10;// - keyFn: function to construct a redis key for the caller&#10;func RateLimit(rdb *redis.Client, max int, window time.Duration, keyFn KeyFunc) gin.HandlerFunc {&#10;&#9;if rdb == nil || max &lt;= 0 || window &lt;= 0 || keyFn == nil {&#10;&#9;&#9;// No-op middleware if misconfigured&#10;&#9;&#9;return func(c *gin.Context) { c.Next() }&#10;&#9;}&#10;&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;ctx := c.Request.Context()&#10;&#9;&#9;key := keyFn(c)&#10;&#10;&#9;&#9;// INCR the counter and set expiry on first hit&#10;&#9;&#9;count, err := rdb.Incr(ctx, key).Result()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;// On Redis error, fail open&#10;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;if count == 1 {&#10;&#9;&#9;&#9;_ = rdb.Expire(ctx, key, window).Err()&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if int(count) &gt; max {&#10;&#9;&#9;&#9;// Optionally set Retry-After header to remaining window&#10;&#9;&#9;&#9;ttl, _ := rdb.TTL(ctx, key).Result()&#10;&#9;&#9;&#9;if ttl &gt; 0 {&#10;&#9;&#9;&#9;&#9;c.Header(&quot;Retry-After&quot;, strconv.Itoa(int(ttl.Seconds())))&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;resp := helpers.Error[any](c, http.StatusTooManyRequests, &quot;rate limit exceeded&quot;, nil)&#10;&#9;&#9;&#9;c.AbortWithStatusJSON(resp.Status, resp)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Continue&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/contracts/contracts.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/contracts/contracts.go" />
              <option name="updatedContent" value="package contracts&#10;&#10;import &quot;github.com/gin-gonic/gin&quot;&#10;&#10;// Module describes a feature module that can register its routes on a RouterGroup&#10;// Example: a User module, Product module, etc.&#10;type Module interface {&#10;&#9;Register(rg *gin.RouterGroup)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/modules/builder.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/modules/builder.go" />
              <option name="updatedContent" value="package modules&#10;&#10;import (&#10;&#9;&quot;boilerplate-go-pgsql/internal/container&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/router/contracts&quot;&#10;&#9;usermodule &quot;boilerplate-go-pgsql/internal/router/modules/user&quot;&#10;&#10;&#9;// construction deps&#10;&#9;appuser &quot;boilerplate-go-pgsql/internal/application/user&quot;&#10;&#9;pginfra &quot;boilerplate-go-pgsql/internal/infrastructure/postgres&quot;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;)&#10;&#10;// BuildAll discovers and builds all available modules from container singletons&#10;// Add new modules here in the future to keep registry clean.&#10;func BuildAll() []contracts.Module {&#10;&#9;mods := make([]contracts.Module, 0, 4)&#10;&#10;&#9;// User module&#10;&#9;if m := buildUserModule(); m != nil {&#10;&#9;&#9;mods = append(mods, m)&#10;&#9;}&#10;&#10;&#9;return mods&#10;}&#10;&#10;func buildUserModule() contracts.Module {&#10;&#9;h := container.GetUserHandler()&#10;&#9;if h == nil {&#10;&#9;&#9;pool := container.GetPGPool()&#10;&#9;&#9;jwt := container.GetJWT()&#10;&#9;&#9;cfg := container.GetConfig()&#10;&#9;&#9;gcs := container.GetGCS()&#10;&#9;&#9;rdb := container.GetRedis()&#10;&#9;&#9;logger := container.GetLogger()&#10;&#9;&#9;if pool != nil &amp;&amp; jwt != nil &amp;&amp; cfg != nil &amp;&amp; logger != nil {&#10;&#9;&#9;&#9;repo := pginfra.NewUserRepository(pool)&#10;&#9;&#9;&#9;svc := appuser.NewService(repo, jwt, gcs, cfg.GCSBucket, rdb, logger)&#10;&#9;&#9;&#9;h = handlers.NewUserHandler(svc, jwt, logger, cfg.CookieDomain, cfg.CookieSecure)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;if h == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;jwt := container.GetJWT()&#10;&#9;return usermodule.New(h, jwt)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/modules/user/module.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/modules/user/module.go" />
              <option name="originalContent" value="package user&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// Module wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type Module struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func New(h *handlers.UserHandler, jwt *helpers.JWTManager) *Module {&#10;&#9;return &amp;Module{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *Module) Register(rg *gin.RouterGroup) {&#10;&#9;// Public&#10;&#9;rg.POST(&quot;/login&quot;, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(m.JWT))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package user&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;boilerplate-go-pgsql/internal/container&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// Module wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type Module struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func New(h *handlers.UserHandler, jwt *helpers.JWTManager) *Module {&#10;&#9;return &amp;Module{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *Module) Register(rg *gin.RouterGroup) {&#10;&#9;// Public with rate limiting&#10;&#9;loginLimiter := middleware.RateLimit(container.GetRedis(), 5, time.Minute, middleware.KeyByIPAndPath())&#10;&#9;refreshLimiter := middleware.RateLimit(container.GetRedis(), 20, time.Minute, middleware.KeyByIPAndPath())&#10;&#10;&#9;rg.POST(&quot;/login&quot;, loginLimiter, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, refreshLimiter, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(m.JWT))&#10;&#9;// Apply a softer per-IP limiter to all protected routes&#10;&#9;auth.Use(middleware.RateLimit(container.GetRedis(), 120, time.Minute, middleware.KeyByIP()))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/router.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/router.go" />
              <option name="originalContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// Register sets up routes and middleware on the given gin Engine for user module&#10;func Register(r *gin.Engine, userHandler *handlers.UserHandler, jwt *helpers.JWTManager) {&#10;&#9;// Public routes&#10;&#9;r.POST(&quot;/login&quot;, userHandler.Login)&#10;&#9;r.POST(&quot;/refresh&quot;, userHandler.Refresh)&#10;&#10;&#9;// Protected routes&#10;&#9;auth := r.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(jwt))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, userHandler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, userHandler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, userHandler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// Register sets up routes and middleware on the given gin Engine for user module&#10;func Register(r *gin.Engine, userHandler *handlers.UserHandler, jwt *helpers.JWTManager) {&#10;&#9;api := r.Group(&quot;/api&quot;)&#10;&#10;&#9;// Public routes&#10;&#9;api.POST(&quot;/login&quot;, userHandler.Login)&#10;&#9;api.POST(&quot;/refresh&quot;, userHandler.Refresh)&#10;&#10;&#9;// Protected routes&#10;&#9;auth := api.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(jwt))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, userHandler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, userHandler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, userHandler.UpdateProfile)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/user_module.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/user_module.go" />
              <option name="updatedContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// UserModule wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type UserModule struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func NewUserModule(h *handlers.UserHandler, jwt *helpers.JWTManager) *UserModule {&#10;&#9;return &amp;UserModule{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *UserModule) Register(rg *gin.RouterGroup) {&#10;&#9;// Public&#10;&#9;rg.POST(&quot;/login&quot;, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(m.JWT))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sqlc.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sqlc.yaml" />
              <option name="updatedContent" value="version: &quot;2&quot;&#10;sql:&#10;  - engine: postgresql&#10;    schema: &quot;db/migrations&quot;&#10;    queries: &quot;db/query&quot;&#10;    gen:&#10;      go:&#10;        package: &quot;pgstore&quot;&#10;        out: &quot;internal/infrastructure/postgres/pgstore&quot;&#10;        sql_package: &quot;pgx/v5&quot;&#10;        emit_json_tags: true&#10;        emit_prepared_queries: false&#10;        emit_exact_table_names: false&#10;        overrides:&#10;          - db_type: &quot;pg_catalog.uuid&quot;&#10;            go_type: &quot;github.com/google/uuid.UUID&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>