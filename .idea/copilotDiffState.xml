<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/internal/application/user/service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/application/user/service.go" />
              <option name="originalContent" value="package userapp&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;domain &quot;boilerplate-go-pgsql/internal/domain/user&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;var (&#10;&#9;ErrInvalidCredentials = errors.New(&quot;invalid credentials&quot;)&#10;&#9;ErrUserNotFound       = errors.New(&quot;user not found&quot;)&#10;)&#10;&#10;type Service struct {&#10;&#9;Repo domain.Repository&#10;&#9;JWT  *helpers.JWTManager&#10;}&#10;&#10;func NewService(repo domain.Repository, jwt *helpers.JWTManager) *Service {&#10;&#9;return &amp;Service{Repo: repo, JWT: jwt}&#10;}&#10;&#10;type LoginResponse struct {&#10;&#9;UserID string `json:&quot;user_id&quot;`&#10;&#9;Email  string `json:&quot;email&quot;`&#10;&#9;Name   string `json:&quot;name&quot;`&#10;}&#10;&#10;func (s *Service) Login(email, password string) (*LoginResponse, string, time.Time, string, time.Time, error) {&#10;&#9;u, err := s.Repo.GetByEmail(email)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;if !helpers.CompareHashAndPassword(u.Password, password) {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;return &amp;LoginResponse{UserID: u.ID, Email: u.Email, Name: u.Name}, access, aexp, refresh, rexp, nil&#10;}&#10;&#10;func (s *Service) Refresh(refreshToken string) (string, time.Time, string, time.Time, string, error) {&#10;&#9;claims, err := s.JWT.ParseRefreshToken(refreshToken)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;// ensure user still exists&#10;&#9;u, err := s.Repo.GetByID(claims.UserID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;return access, aexp, refresh, rexp, u.ID, nil&#10;}&#10;&#10;func (s *Service) GetProfile(userID string) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;type UpdateProfileInput struct {&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;}&#10;&#10;func (s *Service) UpdateProfile(userID string, in UpdateProfileInput) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;if in.Name != &quot;&quot; {&#10;&#9;&#9;u.Name = in.Name&#10;&#9;}&#10;&#9;if in.AvatarURL != &quot;&quot; {&#10;&#9;&#9;u.AvatarURL = in.AvatarURL&#10;&#9;}&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;" />
              <option name="updatedContent" value="package userapp&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;cloud.google.com/go/storage&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;domain &quot;boilerplate-go-pgsql/internal/domain/user&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;var (&#10;&#9;ErrInvalidCredentials = errors.New(&quot;invalid credentials&quot;)&#10;&#9;ErrUserNotFound       = errors.New(&quot;user not found&quot;)&#10;)&#10;&#10;type Service struct {&#10;&#9;Repo      domain.Repository&#10;&#9;JWT       *helpers.JWTManager&#10;&#9;GCS       *storage.Client&#10;&#9;GCSBucket string&#10;&#9;Redis     *redis.Client&#10;&#9;Logger    *logrus.Logger&#10;}&#10;&#10;func NewService(repo domain.Repository, jwt *helpers.JWTManager, gcs *storage.Client, gcsBucket string, rdb *redis.Client, logger *logrus.Logger) *Service {&#10;&#9;return &amp;Service{Repo: repo, JWT: jwt, GCS: gcs, GCSBucket: gcsBucket, Redis: rdb, Logger: logger}&#10;}&#10;&#10;type LoginResponse struct {&#10;&#9;UserID string `json:&quot;user_id&quot;`&#10;&#9;Email  string `json:&quot;email&quot;`&#10;&#9;Name   string `json:&quot;name&quot;`&#10;}&#10;&#10;func (s *Service) Login(email, password string) (*LoginResponse, string, time.Time, string, time.Time, error) {&#10;&#9;u, err := s.Repo.GetByEmail(email)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;if !helpers.CompareHashAndPassword(u.Password, password) {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;return &amp;LoginResponse{UserID: u.ID, Email: u.Email, Name: u.Name}, access, aexp, refresh, rexp, nil&#10;}&#10;&#10;func (s *Service) Refresh(refreshToken string) (string, time.Time, string, time.Time, string, error) {&#10;&#9;claims, err := s.JWT.ParseRefreshToken(refreshToken)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;// ensure user still exists&#10;&#9;u, err := s.Repo.GetByID(claims.UserID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;return access, aexp, refresh, rexp, u.ID, nil&#10;}&#10;&#10;func (s *Service) GetProfile(userID string) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;type UpdateProfileInput struct {&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;}&#10;&#10;func (s *Service) UpdateProfile(userID string, in UpdateProfileInput) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;if in.Name != &quot;&quot; {&#10;&#9;&#9;u.Name = in.Name&#10;&#9;}&#10;&#9;if in.AvatarURL != &quot;&quot; {&#10;&#9;&#9;u.AvatarURL = in.AvatarURL&#10;&#9;}&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;// UploadAvatar demonstrates uploading an avatar to GCS from a reader and updating profile&#10;func (s *Service) UploadAvatar(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, ErrUserNotFound&#10;&#9;}&#10;&#9;url, err := s.uploadImageToGCS(ctx, userID, r, filename, contentType)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;u.AvatarURL = url&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;// cache meta in redis (optional)&#10;&#9;meta := map[string]any{&quot;user_id&quot;: userID, &quot;avatar_url&quot;: url, &quot;updated_at&quot;: time.Now()}&#10;&#9;_ = helpers.RedisSetJSON(ctx, s.Redis, &quot;user:avatar:&quot;+userID, meta, 24*time.Hour)&#10;&#9;return url, nil&#10;}&#10;&#10;func (s *Service) uploadImageToGCS(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;if s.GCS == nil || s.GCSBucket == &quot;&quot; {&#10;&#9;&#9;return &quot;&quot;, errors.New(&quot;gcs not configured&quot;)&#10;&#9;}&#10;&#9;id := uuid.NewString()&#10;&#9;ext := strings.ToLower(filepath.Ext(filename))&#10;&#9;objectPath := filepath.ToSlash(filepath.Join(&quot;avatars&quot;, userID, id+ext))&#10;&#9;return helpers.UploadImageToGCS(ctx, s.GCS, s.GCSBucket, objectPath, contentType, r)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/domain/user/entity.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/domain/user/entity.go" />
              <option name="originalContent" value="package user&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// User is the aggregate root for user domain&#10;// Passwords are stored as bcrypt hashes&#10;//&#10;// In a real-world app, prefer value objects for Email, etc.&#10;type User struct {&#10;&#9;ID           string&#10;&#9;Email        string&#10;&#9;PasswordHash string&#10;&#9;Name         string&#10;&#9;AvatarURL    string&#10;&#9;CreatedAt    time.Time&#10;&#9;UpdatedAt    time.Time&#10;}&#10;" />
              <option name="updatedContent" value="package user&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// User is the aggregate root for user domain&#10;// Passwords are stored as bcrypt hashes in Password field&#10;//&#10;// In a real-world app, prefer value objects for Email, etc.&#10;type User struct {&#10;&#9;ID        string&#10;&#9;Email     string&#10;&#9;Password  string&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;&#9;CreatedAt time.Time&#10;&#9;UpdatedAt time.Time&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/domain/user/repository.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/domain/user/repository.go" />
              <option name="updatedContent" value="package user&#10;&#10;// Repository abstracts persistence for User aggregate&#10;// This lives in the domain layer to decouple application/business logic from infrastructure.&#10;type Repository interface {&#10;&#9;Create(u *User) error&#10;&#9;GetByID(id string) (*User, error)&#10;&#9;GetByEmail(email string) (*User, error)&#10;&#9;Update(u *User) error&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/interface/http/image_handler.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/interface/http/image_handler.go" />
              <option name="updatedContent" value="package handlers&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;mime/multipart&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;cloud.google.com/go/storage&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;type ImageHandler struct {&#10;&#9;GCS    *storage.Client&#10;&#9;Bucket string&#10;&#9;Redis  *redis.Client&#10;&#9;Logger *logrus.Logger&#10;}&#10;&#10;func NewImageHandler(gcs *storage.Client, bucket string, rdb *redis.Client, logger *logrus.Logger) *ImageHandler {&#10;&#9;return &amp;ImageHandler{GCS: gcs, Bucket: bucket, Redis: rdb, Logger: logger}&#10;}&#10;&#10;type ImageMeta struct {&#10;&#9;ID          string    `json:&quot;id&quot;`&#10;&#9;URL         string    `json:&quot;url&quot;`&#10;&#9;ContentType string    `json:&quot;content_type&quot;`&#10;&#9;UploaderID  string    `json:&quot;uploader_id&quot;`&#10;&#9;CreatedAt   time.Time `json:&quot;created_at&quot;`&#10;}&#10;&#10;func (h *ImageHandler) Upload(c *gin.Context) {&#10;&#9;uid := c.GetString(&quot;userID&quot;)&#10;&#9;file, header, err := c.Request.FormFile(&quot;file&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusBadRequest, &quot;file is required&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer file.Close()&#10;&#10;&#9;contentType := sniffContentType(header)&#10;&#9;id := uuid.NewString()&#10;&#9;ext := strings.ToLower(filepath.Ext(header.Filename))&#10;&#9;objectPath := fmt.Sprintf(&quot;uploads/%s/%s%s&quot;, uid, id, ext)&#10;&#10;&#9;url, err := helpers.UploadObject(c.Request.Context(), h.GCS, h.Bucket, objectPath, contentType, file)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusInternalServerError, &quot;upload failed&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;meta := &amp;ImageMeta{ID: id, URL: url, ContentType: contentType, UploaderID: uid, CreatedAt: time.Now()}&#10;&#9;_ = helpers.RedisSetJSON(c.Request.Context(), h.Redis, imageKey(id), meta, 24*time.Hour)&#10;&#9;c.JSON(http.StatusOK, helpers.APIResponse(meta, &quot;uploaded&quot;))&#10;}&#10;&#10;func (h *ImageHandler) Get(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var meta ImageMeta&#10;&#9;found, err := helpers.RedisGetJSON(c.Request.Context(), h.Redis, imageKey(id), &amp;meta)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusInternalServerError, &quot;cache error&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;if !found {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusNotFound, &quot;image not found&quot;, nil)&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;c.JSON(http.StatusOK, helpers.APIResponse(meta, &quot;ok&quot;))&#10;}&#10;&#10;func sniffContentType(h *multipart.FileHeader) string {&#10;&#9;if h.Header.Get(&quot;Content-Type&quot;) != &quot;&quot; {&#10;&#9;&#9;return h.Header.Get(&quot;Content-Type&quot;)&#10;&#9;}&#10;&#9;return &quot;application/octet-stream&quot;&#10;}&#10;&#10;func imageKey(id string) string { return &quot;image:&quot; + id }&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/contracts/contracts.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/contracts/contracts.go" />
              <option name="updatedContent" value="package contracts&#10;&#10;import &quot;github.com/gin-gonic/gin&quot;&#10;&#10;// Module describes a feature module that can register its routes on a RouterGroup&#10;// Example: a User module, Product module, etc.&#10;type Module interface {&#10;&#9;Register(rg *gin.RouterGroup)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/modules/builder.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/modules/builder.go" />
              <option name="updatedContent" value="package modules&#10;&#10;import (&#10;&#9;&quot;boilerplate-go-pgsql/internal/container&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/router/contracts&quot;&#10;&#9;usermodule &quot;boilerplate-go-pgsql/internal/router/modules/user&quot;&#10;&#10;&#9;// construction deps&#10;&#9;appuser &quot;boilerplate-go-pgsql/internal/application/user&quot;&#10;&#9;pginfra &quot;boilerplate-go-pgsql/internal/infrastructure/postgres&quot;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;)&#10;&#10;// BuildAll discovers and builds all available modules from container singletons&#10;// Add new modules here in the future to keep registry clean.&#10;func BuildAll() []contracts.Module {&#10;&#9;mods := make([]contracts.Module, 0, 4)&#10;&#10;&#9;// User module&#10;&#9;if m := buildUserModule(); m != nil {&#10;&#9;&#9;mods = append(mods, m)&#10;&#9;}&#10;&#10;&#9;return mods&#10;}&#10;&#10;func buildUserModule() contracts.Module {&#10;&#9;h := container.GetUserHandler()&#10;&#9;if h == nil {&#10;&#9;&#9;pool := container.GetPGPool()&#10;&#9;&#9;jwt := container.GetJWT()&#10;&#9;&#9;cfg := container.GetConfig()&#10;&#9;&#9;gcs := container.GetGCS()&#10;&#9;&#9;rdb := container.GetRedis()&#10;&#9;&#9;logger := container.GetLogger()&#10;&#9;&#9;if pool != nil &amp;&amp; jwt != nil &amp;&amp; cfg != nil &amp;&amp; logger != nil {&#10;&#9;&#9;&#9;repo := pginfra.NewUserRepository(pool)&#10;&#9;&#9;&#9;svc := appuser.NewService(repo, jwt, gcs, cfg.GCSBucket, rdb, logger)&#10;&#9;&#9;&#9;h = handlers.NewUserHandler(svc, jwt, logger, cfg.CookieDomain, cfg.CookieSecure)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;if h == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;jwt := container.GetJWT()&#10;&#9;return usermodule.New(h, jwt)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/modules/user/module.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/modules/user/module.go" />
              <option name="originalContent" value="package user&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/container&quot;&#10;&#10;&#9;handlers &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/interface/http&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/interface/middleware&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/pkg/helpers&quot;&#10;)&#10;&#10;// Module wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type Module struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func New(h *handlers.UserHandler, jwt *helpers.JWTManager) *Module {&#10;&#9;return &amp;Module{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *Module) Register(rg *gin.RouterGroup) {&#10;&#9;// Public with rate limiting&#10;&#9;loginLimiter := middleware.RateLimit(container.GetRedis(), 5, time.Minute, middleware.KeyByIPAndPath())&#10;&#9;refreshLimiter := middleware.RateLimit(container.GetRedis(), 20, time.Minute, middleware.KeyByIPAndPath())&#10;&#10;&#9;rg.POST(&quot;/login&quot;, loginLimiter, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, refreshLimiter, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(m.JWT))&#10;&#9;// Apply a softer per-IP limiter to all protected routes&#10;&#9;auth.Use(middleware.RateLimit(container.GetRedis(), 120, time.Minute, middleware.KeyByIP()))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package user&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/container&quot;&#10;&#10;&#9;handlers &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/interface/http&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/interface/middleware&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/pkg/helpers&quot;&#10;)&#10;&#10;// Module wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type Module struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func New(h *handlers.UserHandler, jwt *helpers.JWTManager) *Module {&#10;&#9;return &amp;Module{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *Module) Register(rg *gin.RouterGroup) {&#10;&#9;// Public with rate limiting&#10;&#9;loginLimiter := middleware.RateLimit(container.GetRedis(), 5, time.Minute, middleware.KeyByIPAndPath())&#10;&#9;refreshLimiter := middleware.RateLimit(container.GetRedis(), 20, time.Minute, middleware.KeyByIPAndPath())&#10;&#10;&#9;rg.POST(&quot;/login&quot;, loginLimiter, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, refreshLimiter, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.Auth(container.GetRedis(), m.JWT))&#10;&#9;// Apply a softer per-IP limiter to all protected routes&#10;&#9;auth.Use(middleware.RateLimit(container.GetRedis(), 120, time.Minute, middleware.KeyByIP()))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/router.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/router.go" />
              <option name="originalContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// Register sets up routes and middleware on the given gin Engine for user module&#10;func Register(r *gin.Engine, userHandler *handlers.UserHandler, jwt *helpers.JWTManager) {&#10;&#9;// Public routes&#10;&#9;r.POST(&quot;/login&quot;, userHandler.Login)&#10;&#9;r.POST(&quot;/refresh&quot;, userHandler.Refresh)&#10;&#10;&#9;// Protected routes&#10;&#9;auth := r.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(jwt))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, userHandler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, userHandler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, userHandler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// Register sets up routes and middleware on the given gin Engine for user module&#10;func Register(r *gin.Engine, userHandler *handlers.UserHandler, jwt *helpers.JWTManager) {&#10;&#9;api := r.Group(&quot;/api&quot;)&#10;&#10;&#9;// Public routes&#10;&#9;api.POST(&quot;/login&quot;, userHandler.Login)&#10;&#9;api.POST(&quot;/refresh&quot;, userHandler.Refresh)&#10;&#10;&#9;// Protected routes&#10;&#9;auth := api.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(jwt))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, userHandler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, userHandler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, userHandler.UpdateProfile)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/user_module.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/user_module.go" />
              <option name="updatedContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// UserModule wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type UserModule struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func NewUserModule(h *handlers.UserHandler, jwt *helpers.JWTManager) *UserModule {&#10;&#9;return &amp;UserModule{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *UserModule) Register(rg *gin.RouterGroup) {&#10;&#9;// Public&#10;&#9;rg.POST(&quot;/login&quot;, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(m.JWT))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>