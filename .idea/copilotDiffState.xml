<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/cmd/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cmd/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;database/sql&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;os/signal&quot;&#10;&#9;&quot;syscall&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-contrib/cors&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;&quot;github.com/golang-migrate/migrate/v4&quot;&#10;&#9;pgmigrate &quot;github.com/golang-migrate/migrate/v4/database/postgres&quot;&#10;&#9;_ &quot;github.com/golang-migrate/migrate/v4/source/file&quot;&#10;&#9;_ &quot;github.com/jackc/pgx/v5/stdlib&quot;&#10;&#10;&#9;&quot;boilerplate-go-pgsql/configs&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/container&quot;&#10;&#9;pginfra &quot;boilerplate-go-pgsql/internal/infrastructure/postgres&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/router&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;func main() {&#10;&#9;_ = godotenv.Load() // load .env if present&#10;&#10;&#9;cfg := configs.Load()&#10;&#9;logger := helpers.NewLogger(cfg.AppName, cfg.Env)&#10;&#9;gin.SetMode(cfg.GinMode)&#10;&#10;&#9;ctx := context.Background()&#10;&#10;&#9;// Initialize Postgres pool&#10;&#9;pool, err := pginfra.NewPool(ctx, cfg.PostgresDSN(), cfg.DBMaxConns, cfg.DBMinConns, cfg.DBMaxConnLife)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;failed to connect to postgres: %v&quot;, err)&#10;&#9;}&#10;&#9;defer pool.Close()&#10;&#10;&#9;// Run migrations using database/sql with pgx stdlib&#10;&#9;if err := runMigrations(cfg.PostgresDSN(), cfg.MigrationsDir, logger); err != nil &amp;&amp; !errors.Is(migrate.ErrNoChange, err) {&#10;&#9;&#9;log.Fatalf(&quot;migration failed: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Redis&#10;&#9;rdb := helpers.NewRedisClient(cfg.RedisAddr, cfg.RedisPassword, cfg.RedisDB)&#10;&#9;defer func() { _ = rdb.Close() }()&#10;&#10;&#9;// GCS (available for DI in services that need it)&#10;&#9;gcsClient, err := helpers.NewGCSClient(ctx, cfg.GCSCredentialsJSONPath)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;failed to init GCS client: %v&quot;, err)&#10;&#9;}&#10;&#9;defer func() { _ = gcsClient.Close() }()&#10;&#10;&#9;// JWT&#10;&#9;jwtManager := helpers.NewJWTManager(cfg.JWTAccessSecret, cfg.JWTRefreshSecret, cfg.AccessTTL, cfg.RefreshTTL)&#10;&#10;&#9;// Provide infra singletons to container for registry auto-wiring&#10;&#9;container.SetConfig(cfg)&#10;&#9;container.SetLogger(logger)&#10;&#9;container.SetPGPool(pool)&#10;&#9;container.SetRedis(rdb)&#10;&#9;container.SetGCS(gcsClient)&#10;&#9;container.SetJWT(jwtManager)&#10;&#10;&#9;// Gin engine and global middleware&#10;&#9;r := gin.New()&#10;&#9;r.Use(gin.Recovery())&#10;&#9;r.Use(middleware.RequestIDMiddleware())&#10;&#9;// CORS&#10;&#9;corsCfg := cors.Config{&#10;&#9;&#9;AllowOrigins:     cfg.CORSOrigins(),&#10;&#9;&#9;AllowMethods:     []string{&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;PATCH&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;},&#10;&#9;&#9;AllowHeaders:     []string{&quot;Origin&quot;, &quot;Content-Type&quot;, &quot;Accept&quot;, &quot;Authorization&quot;},&#10;&#9;&#9;ExposeHeaders:    []string{&quot;Content-Length&quot;},&#10;&#9;&#9;AllowCredentials: true,&#10;&#9;&#9;MaxAge:           12 * time.Hour,&#10;&#9;}&#10;&#9;r.Use(cors.New(corsCfg))&#10;&#9;if cfg.Env == &quot;development&quot; {&#10;&#9;&#9;r.Use(gin.Logger())&#10;&#9;}&#10;&#10;&#9;// Registry: auto-register modules using container&#10;&#9;reg := router.NewRegistry(r)&#10;&#9;router.InitModules(reg)&#10;&#9;reg.RegisterAll()&#10;&#10;&#9;srv := &amp;http.Server{Addr: &quot;:&quot; + cfg.Port, Handler: r}&#10;&#9;go func() {&#10;&#9;&#9;logger.Infof(&quot;server starting on :%s&quot;, cfg.Port)&#10;&#9;&#9;if err := srv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(http.ErrServerClosed, err) {&#10;&#9;&#9;&#9;logger.Fatalf(&quot;listen: %s\n&quot;, err)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;// Graceful shutdown&#10;&#9;quit := make(chan os.Signal, 1)&#10;&#9;signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)&#10;&#9;&lt;-quit&#10;&#9;logger.Info(&quot;shutting down server&quot;)&#10;&#10;&#9;ctxShutdown, cancel := context.WithTimeout(context.Background(), 10*time.Second)&#10;&#9;defer cancel()&#10;&#9;if err := srv.Shutdown(ctxShutdown); err != nil {&#10;&#9;&#9;logger.Fatalf(&quot;server forced to shutdown: %v&quot;, err)&#10;&#9;}&#10;&#9;logger.Info(&quot;server exited properly&quot;)&#10;}&#10;&#10;func runMigrations(dsn string, migrationsDir string, logger *logrus.Logger) error {&#10;&#9;// Open sql DB via pgx stdlib&#10;&#9;db, err := sql.Open(&quot;pgx&quot;, dsn)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;defer func() { _ = db.Close() }()&#10;&#9;driver, err := pgmigrate.WithInstance(db, &amp;pgmigrate.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;m, err := migrate.NewWithDatabaseInstance(fmt.Sprintf(&quot;file://%s&quot;, migrationsDir), &quot;postgres&quot;, driver)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;logger.Info(&quot;running migrations...&quot;)&#10;&#9;err = m.Up()&#10;&#9;if errors.Is(migrate.ErrNoChange, err) {&#10;&#9;&#9;logger.Info(&quot;no migrations to run&quot;)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;return err&#10;}&#10;" />
              <option name="updatedContent" value="package main&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;context&quot;&#13;&#10;&#9;&quot;database/sql&quot;&#13;&#10;&#9;&quot;errors&quot;&#13;&#10;&#9;&quot;fmt&quot;&#13;&#10;&#9;&quot;log&quot;&#13;&#10;&#9;&quot;net/http&quot;&#13;&#10;&#9;&quot;os&quot;&#13;&#10;&#9;&quot;os/signal&quot;&#13;&#10;&#9;&quot;syscall&quot;&#13;&#10;&#9;&quot;time&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/gin-contrib/cors&quot;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#13;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/golang-migrate/migrate/v4&quot;&#13;&#10;&#9;pgmigrate &quot;github.com/golang-migrate/migrate/v4/database/postgres&quot;&#13;&#10;&#9;_ &quot;github.com/golang-migrate/migrate/v4/source/file&quot;&#13;&#10;&#9;_ &quot;github.com/jackc/pgx/v5/stdlib&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/configs&quot;&#13;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/container&quot;&#13;&#10;&#9;pginfra &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/infrastructure/postgres&quot;&#13;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/interface/middleware&quot;&#13;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/router&quot;&#13;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/pkg/helpers&quot;&#13;&#10;)&#13;&#10;&#13;&#10;func main() {&#13;&#10;&#9;_ = godotenv.Load() // load .env if present&#13;&#10;&#13;&#10;&#9;cfg := configs.Load()&#13;&#10;&#9;logger := helpers.NewLogger(cfg.AppName, cfg.Env)&#13;&#10;&#9;gin.SetMode(cfg.GinMode)&#13;&#10;&#13;&#10;&#9;ctx := context.Background()&#13;&#10;&#13;&#10;&#9;// Initialize Postgres pool&#13;&#10;&#9;pool, err := pginfra.NewPool(ctx, cfg.PostgresDSN(), cfg.DBMaxConns, cfg.DBMinConns, cfg.DBMaxConnLife)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;log.Fatalf(&quot;failed to connect to postgres: %v&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#9;defer pool.Close()&#13;&#10;&#13;&#10;&#9;// Run migrations using database/sql with pgx stdlib&#13;&#10;&#9;if err := runMigrations(cfg.PostgresDSN(), cfg.MigrationsDir, logger); err != nil &amp;&amp; !errors.Is(migrate.ErrNoChange, err) {&#13;&#10;&#9;&#9;log.Fatalf(&quot;migration failed: %v&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Redis&#13;&#10;&#9;rdb := helpers.NewRedisClient(cfg.RedisAddr, cfg.RedisPassword, cfg.RedisDB)&#13;&#10;&#9;defer func() { _ = rdb.Close() }()&#13;&#10;&#13;&#10;&#9;// GCS (available for DI in services that need it)&#13;&#10;&#9;gcsClient, err := helpers.NewGCSClient(ctx, cfg.GCSCredentialsJSONPath)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;log.Fatalf(&quot;failed to init GCS client: %v&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#9;defer func() { _ = gcsClient.Close() }()&#13;&#10;&#13;&#10;&#9;// JWT&#13;&#10;&#9;jwtManager := helpers.NewJWTManager(cfg.JWTAccessSecret, cfg.JWTRefreshSecret, cfg.AccessTTL, cfg.RefreshTTL)&#13;&#10;&#13;&#10;&#9;// Provide infra singletons to container for registry auto-wiring&#13;&#10;&#9;container.SetConfig(cfg)&#13;&#10;&#9;container.SetLogger(logger)&#13;&#10;&#9;container.SetPGPool(pool)&#13;&#10;&#9;container.SetRedis(rdb)&#13;&#10;&#9;container.SetGCS(gcsClient)&#13;&#10;&#9;container.SetJWT(jwtManager)&#13;&#10;&#13;&#10;&#9;// Gin engine and global middleware&#13;&#10;&#9;r := gin.New()&#13;&#10;&#9;r.Use(gin.Recovery())&#13;&#10;&#9;r.Use(middleware.RequestIDMiddleware())&#13;&#10;&#9;// CORS&#13;&#10;&#9;corsCfg := cors.Config{&#13;&#10;&#9;&#9;AllowOrigins:     cfg.CORSOrigins(),&#13;&#10;&#9;&#9;AllowMethods:     []string{&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;PATCH&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;},&#13;&#10;&#9;&#9;AllowHeaders:     []string{&quot;Origin&quot;, &quot;Content-Type&quot;, &quot;Accept&quot;, &quot;Authorization&quot;},&#13;&#10;&#9;&#9;ExposeHeaders:    []string{&quot;Content-Length&quot;},&#13;&#10;&#9;&#9;AllowCredentials: true,&#13;&#10;&#9;&#9;MaxAge:           12 * time.Hour,&#13;&#10;&#9;}&#13;&#10;&#9;r.Use(cors.New(corsCfg))&#13;&#10;&#9;if cfg.Env == &quot;development&quot; {&#13;&#10;&#9;&#9;r.Use(gin.Logger())&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Registry: auto-register modules using container&#13;&#10;&#9;reg := router.NewRegistry(r)&#13;&#10;&#9;router.InitModules(reg)&#13;&#10;&#9;reg.RegisterAll()&#13;&#10;&#13;&#10;&#9;srv := &amp;http.Server{Addr: &quot;:&quot; + cfg.Port, Handler: r}&#13;&#10;&#9;go func() {&#13;&#10;&#9;&#9;logger.Infof(&quot;server starting on :%s&quot;, cfg.Port)&#13;&#10;&#9;&#9;if err := srv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(http.ErrServerClosed, err) {&#13;&#10;&#9;&#9;&#9;logger.Fatalf(&quot;listen: %s\n&quot;, err)&#13;&#10;&#9;&#9;}&#13;&#10;&#9;}()&#13;&#10;&#13;&#10;&#9;// Graceful shutdown&#13;&#10;&#9;quit := make(chan os.Signal, 1)&#13;&#10;&#9;signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)&#13;&#10;&#9;&lt;-quit&#13;&#10;&#9;logger.Info(&quot;shutting down server&quot;)&#13;&#10;&#13;&#10;&#9;ctxShutdown, cancel := context.WithTimeout(context.Background(), 10*time.Second)&#13;&#10;&#9;defer cancel()&#13;&#10;&#9;if err := srv.Shutdown(ctxShutdown); err != nil {&#13;&#10;&#9;&#9;logger.Fatalf(&quot;server forced to shutdown: %v&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#9;logger.Info(&quot;server exited properly&quot;)&#13;&#10;}&#13;&#10;&#13;&#10;func runMigrations(dsn string, migrationsDir string, logger *logrus.Logger) error {&#13;&#10;&#9;// Open sql DB via pgx stdlib&#13;&#10;&#9;db, err := sql.Open(&quot;pgx&quot;, dsn)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return err&#13;&#10;&#9;}&#13;&#10;&#9;defer func() { _ = db.Close() }()&#13;&#10;&#9;driver, err := pgmigrate.WithInstance(db, &amp;pgmigrate.Config{})&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return err&#13;&#10;&#9;}&#13;&#10;&#9;m, err := migrate.NewWithDatabaseInstance(fmt.Sprintf(&quot;file://%s&quot;, migrationsDir), &quot;postgres&quot;, driver)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return err&#13;&#10;&#9;}&#13;&#10;&#9;logger.Info(&quot;running migrations...&quot;)&#13;&#10;&#9;err = m.Up()&#13;&#10;&#9;if errors.Is(migrate.ErrNoChange, err) {&#13;&#10;&#9;&#9;logger.Info(&quot;no migrations to run&quot;)&#13;&#10;&#9;&#9;return nil&#13;&#10;&#9;}&#13;&#10;&#9;return err&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/application/user/service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/application/user/service.go" />
              <option name="originalContent" value="package userapp&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;domain &quot;boilerplate-go-pgsql/internal/domain/user&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;var (&#10;&#9;ErrInvalidCredentials = errors.New(&quot;invalid credentials&quot;)&#10;&#9;ErrUserNotFound       = errors.New(&quot;user not found&quot;)&#10;)&#10;&#10;type Service struct {&#10;&#9;Repo domain.Repository&#10;&#9;JWT  *helpers.JWTManager&#10;}&#10;&#10;func NewService(repo domain.Repository, jwt *helpers.JWTManager) *Service {&#10;&#9;return &amp;Service{Repo: repo, JWT: jwt}&#10;}&#10;&#10;type LoginResponse struct {&#10;&#9;UserID string `json:&quot;user_id&quot;`&#10;&#9;Email  string `json:&quot;email&quot;`&#10;&#9;Name   string `json:&quot;name&quot;`&#10;}&#10;&#10;func (s *Service) Login(email, password string) (*LoginResponse, string, time.Time, string, time.Time, error) {&#10;&#9;u, err := s.Repo.GetByEmail(email)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;if !helpers.CompareHashAndPassword(u.Password, password) {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;return &amp;LoginResponse{UserID: u.ID, Email: u.Email, Name: u.Name}, access, aexp, refresh, rexp, nil&#10;}&#10;&#10;func (s *Service) Refresh(refreshToken string) (string, time.Time, string, time.Time, string, error) {&#10;&#9;claims, err := s.JWT.ParseRefreshToken(refreshToken)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;// ensure user still exists&#10;&#9;u, err := s.Repo.GetByID(claims.UserID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;return access, aexp, refresh, rexp, u.ID, nil&#10;}&#10;&#10;func (s *Service) GetProfile(userID string) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;type UpdateProfileInput struct {&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;}&#10;&#10;func (s *Service) UpdateProfile(userID string, in UpdateProfileInput) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;if in.Name != &quot;&quot; {&#10;&#9;&#9;u.Name = in.Name&#10;&#9;}&#10;&#9;if in.AvatarURL != &quot;&quot; {&#10;&#9;&#9;u.AvatarURL = in.AvatarURL&#10;&#9;}&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;" />
              <option name="updatedContent" value="package userapp&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;cloud.google.com/go/storage&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;domain &quot;boilerplate-go-pgsql/internal/domain/user&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;var (&#10;&#9;ErrInvalidCredentials = errors.New(&quot;invalid credentials&quot;)&#10;&#9;ErrUserNotFound       = errors.New(&quot;user not found&quot;)&#10;)&#10;&#10;type Service struct {&#10;&#9;Repo      domain.Repository&#10;&#9;JWT       *helpers.JWTManager&#10;&#9;GCS       *storage.Client&#10;&#9;GCSBucket string&#10;&#9;Redis     *redis.Client&#10;&#9;Logger    *logrus.Logger&#10;}&#10;&#10;func NewService(repo domain.Repository, jwt *helpers.JWTManager, gcs *storage.Client, gcsBucket string, rdb *redis.Client, logger *logrus.Logger) *Service {&#10;&#9;return &amp;Service{Repo: repo, JWT: jwt, GCS: gcs, GCSBucket: gcsBucket, Redis: rdb, Logger: logger}&#10;}&#10;&#10;type LoginResponse struct {&#10;&#9;UserID string `json:&quot;user_id&quot;`&#10;&#9;Email  string `json:&quot;email&quot;`&#10;&#9;Name   string `json:&quot;name&quot;`&#10;}&#10;&#10;func (s *Service) Login(email, password string) (*LoginResponse, string, time.Time, string, time.Time, error) {&#10;&#9;u, err := s.Repo.GetByEmail(email)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;if !helpers.CompareHashAndPassword(u.Password, password) {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;return &amp;LoginResponse{UserID: u.ID, Email: u.Email, Name: u.Name}, access, aexp, refresh, rexp, nil&#10;}&#10;&#10;func (s *Service) Refresh(refreshToken string) (string, time.Time, string, time.Time, string, error) {&#10;&#9;claims, err := s.JWT.ParseRefreshToken(refreshToken)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;// ensure user still exists&#10;&#9;u, err := s.Repo.GetByID(claims.UserID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;return access, aexp, refresh, rexp, u.ID, nil&#10;}&#10;&#10;func (s *Service) GetProfile(userID string) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;type UpdateProfileInput struct {&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;}&#10;&#10;func (s *Service) UpdateProfile(userID string, in UpdateProfileInput) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;if in.Name != &quot;&quot; {&#10;&#9;&#9;u.Name = in.Name&#10;&#9;}&#10;&#9;if in.AvatarURL != &quot;&quot; {&#10;&#9;&#9;u.AvatarURL = in.AvatarURL&#10;&#9;}&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;// UploadAvatar demonstrates uploading an avatar to GCS from a reader and updating profile&#10;func (s *Service) UploadAvatar(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, ErrUserNotFound&#10;&#9;}&#10;&#9;url, err := s.uploadImageToGCS(ctx, userID, r, filename, contentType)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;u.AvatarURL = url&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;// cache meta in redis (optional)&#10;&#9;meta := map[string]any{&quot;user_id&quot;: userID, &quot;avatar_url&quot;: url, &quot;updated_at&quot;: time.Now()}&#10;&#9;_ = helpers.RedisSetJSON(ctx, s.Redis, &quot;user:avatar:&quot;+userID, meta, 24*time.Hour)&#10;&#9;return url, nil&#10;}&#10;&#10;func (s *Service) uploadImageToGCS(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;if s.GCS == nil || s.GCSBucket == &quot;&quot; {&#10;&#9;&#9;return &quot;&quot;, errors.New(&quot;gcs not configured&quot;)&#10;&#9;}&#10;&#9;id := uuid.NewString()&#10;&#9;ext := strings.ToLower(filepath.Ext(filename))&#10;&#9;objectPath := filepath.ToSlash(filepath.Join(&quot;avatars&quot;, userID, id+ext))&#10;&#9;return helpers.UploadImageToGCS(ctx, s.GCS, s.GCSBucket, objectPath, contentType, r)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/domain/user/entity.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/domain/user/entity.go" />
              <option name="originalContent" value="package user&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// User is the aggregate root for user domain&#10;// Passwords are stored as bcrypt hashes&#10;//&#10;// In a real-world app, prefer value objects for Email, etc.&#10;type User struct {&#10;&#9;ID           string&#10;&#9;Email        string&#10;&#9;PasswordHash string&#10;&#9;Name         string&#10;&#9;AvatarURL    string&#10;&#9;CreatedAt    time.Time&#10;&#9;UpdatedAt    time.Time&#10;}&#10;" />
              <option name="updatedContent" value="package user&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// User is the aggregate root for user domain&#10;// Passwords are stored as bcrypt hashes in Password field&#10;//&#10;// In a real-world app, prefer value objects for Email, etc.&#10;type User struct {&#10;&#9;ID        string&#10;&#9;Email     string&#10;&#9;Password  string&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;&#9;CreatedAt time.Time&#10;&#9;UpdatedAt time.Time&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/domain/user/repository.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/domain/user/repository.go" />
              <option name="updatedContent" value="package user&#10;&#10;// Repository abstracts persistence for User aggregate&#10;// This lives in the domain layer to decouple application/business logic from infrastructure.&#10;type Repository interface {&#10;&#9;Create(u *User) error&#10;&#9;GetByID(id string) (*User, error)&#10;&#9;GetByEmail(email string) (*User, error)&#10;&#9;Update(u *User) error&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/interface/http/image_handler.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/interface/http/image_handler.go" />
              <option name="updatedContent" value="package handlers&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;mime/multipart&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;cloud.google.com/go/storage&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;type ImageHandler struct {&#10;&#9;GCS    *storage.Client&#10;&#9;Bucket string&#10;&#9;Redis  *redis.Client&#10;&#9;Logger *logrus.Logger&#10;}&#10;&#10;func NewImageHandler(gcs *storage.Client, bucket string, rdb *redis.Client, logger *logrus.Logger) *ImageHandler {&#10;&#9;return &amp;ImageHandler{GCS: gcs, Bucket: bucket, Redis: rdb, Logger: logger}&#10;}&#10;&#10;type ImageMeta struct {&#10;&#9;ID          string    `json:&quot;id&quot;`&#10;&#9;URL         string    `json:&quot;url&quot;`&#10;&#9;ContentType string    `json:&quot;content_type&quot;`&#10;&#9;UploaderID  string    `json:&quot;uploader_id&quot;`&#10;&#9;CreatedAt   time.Time `json:&quot;created_at&quot;`&#10;}&#10;&#10;func (h *ImageHandler) Upload(c *gin.Context) {&#10;&#9;uid := c.GetString(&quot;userID&quot;)&#10;&#9;file, header, err := c.Request.FormFile(&quot;file&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusBadRequest, &quot;file is required&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer file.Close()&#10;&#10;&#9;contentType := sniffContentType(header)&#10;&#9;id := uuid.NewString()&#10;&#9;ext := strings.ToLower(filepath.Ext(header.Filename))&#10;&#9;objectPath := fmt.Sprintf(&quot;uploads/%s/%s%s&quot;, uid, id, ext)&#10;&#10;&#9;url, err := helpers.UploadObject(c.Request.Context(), h.GCS, h.Bucket, objectPath, contentType, file)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusInternalServerError, &quot;upload failed&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;meta := &amp;ImageMeta{ID: id, URL: url, ContentType: contentType, UploaderID: uid, CreatedAt: time.Now()}&#10;&#9;_ = helpers.RedisSetJSON(c.Request.Context(), h.Redis, imageKey(id), meta, 24*time.Hour)&#10;&#9;c.JSON(http.StatusOK, helpers.APIResponse(meta, &quot;uploaded&quot;))&#10;}&#10;&#10;func (h *ImageHandler) Get(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var meta ImageMeta&#10;&#9;found, err := helpers.RedisGetJSON(c.Request.Context(), h.Redis, imageKey(id), &amp;meta)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusInternalServerError, &quot;cache error&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;if !found {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusNotFound, &quot;image not found&quot;, nil)&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;c.JSON(http.StatusOK, helpers.APIResponse(meta, &quot;ok&quot;))&#10;}&#10;&#10;func sniffContentType(h *multipart.FileHeader) string {&#10;&#9;if h.Header.Get(&quot;Content-Type&quot;) != &quot;&quot; {&#10;&#9;&#9;return h.Header.Get(&quot;Content-Type&quot;)&#10;&#9;}&#10;&#9;return &quot;application/octet-stream&quot;&#10;}&#10;&#10;func imageKey(id string) string { return &quot;image:&quot; + id }&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/contracts/contracts.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/contracts/contracts.go" />
              <option name="updatedContent" value="package contracts&#10;&#10;import &quot;github.com/gin-gonic/gin&quot;&#10;&#10;// Module describes a feature module that can register its routes on a RouterGroup&#10;// Example: a User module, Product module, etc.&#10;type Module interface {&#10;&#9;Register(rg *gin.RouterGroup)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/modules/builder.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/modules/builder.go" />
              <option name="updatedContent" value="package modules&#10;&#10;import (&#10;&#9;&quot;boilerplate-go-pgsql/internal/container&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/router/contracts&quot;&#10;&#9;usermodule &quot;boilerplate-go-pgsql/internal/router/modules/user&quot;&#10;&#10;&#9;// construction deps&#10;&#9;appuser &quot;boilerplate-go-pgsql/internal/application/user&quot;&#10;&#9;pginfra &quot;boilerplate-go-pgsql/internal/infrastructure/postgres&quot;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;)&#10;&#10;// BuildAll discovers and builds all available modules from container singletons&#10;// Add new modules here in the future to keep registry clean.&#10;func BuildAll() []contracts.Module {&#10;&#9;mods := make([]contracts.Module, 0, 4)&#10;&#10;&#9;// User module&#10;&#9;if m := buildUserModule(); m != nil {&#10;&#9;&#9;mods = append(mods, m)&#10;&#9;}&#10;&#10;&#9;return mods&#10;}&#10;&#10;func buildUserModule() contracts.Module {&#10;&#9;h := container.GetUserHandler()&#10;&#9;if h == nil {&#10;&#9;&#9;pool := container.GetPGPool()&#10;&#9;&#9;jwt := container.GetJWT()&#10;&#9;&#9;cfg := container.GetConfig()&#10;&#9;&#9;gcs := container.GetGCS()&#10;&#9;&#9;rdb := container.GetRedis()&#10;&#9;&#9;logger := container.GetLogger()&#10;&#9;&#9;if pool != nil &amp;&amp; jwt != nil &amp;&amp; cfg != nil &amp;&amp; logger != nil {&#10;&#9;&#9;&#9;repo := pginfra.NewUserRepository(pool)&#10;&#9;&#9;&#9;svc := appuser.NewService(repo, jwt, gcs, cfg.GCSBucket, rdb, logger)&#10;&#9;&#9;&#9;h = handlers.NewUserHandler(svc, jwt, logger, cfg.CookieDomain, cfg.CookieSecure)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;if h == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;jwt := container.GetJWT()&#10;&#9;return usermodule.New(h, jwt)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/modules/user/module.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/modules/user/module.go" />
              <option name="originalContent" value="package user&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;boilerplate-go-pgsql/internal/container&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// Module wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type Module struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func New(h *handlers.UserHandler, jwt *helpers.JWTManager) *Module {&#10;&#9;return &amp;Module{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *Module) Register(rg *gin.RouterGroup) {&#10;&#9;// Public with rate limiting&#10;&#9;loginLimiter := middleware.RateLimit(container.GetRedis(), 5, time.Minute, middleware.KeyByIPAndPath())&#10;&#9;refreshLimiter := middleware.RateLimit(container.GetRedis(), 20, time.Minute, middleware.KeyByIPAndPath())&#10;&#10;&#9;rg.POST(&quot;/login&quot;, loginLimiter, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, refreshLimiter, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(m.JWT))&#10;&#9;// Apply a softer per-IP limiter to all protected routes&#10;&#9;auth.Use(middleware.RateLimit(container.GetRedis(), 120, time.Minute, middleware.KeyByIP()))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package user&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/container&quot;&#10;&#10;&#9;handlers &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/interface/http&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/interface/middleware&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/pkg/helpers&quot;&#10;)&#10;&#10;// Module wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type Module struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func New(h *handlers.UserHandler, jwt *helpers.JWTManager) *Module {&#10;&#9;return &amp;Module{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *Module) Register(rg *gin.RouterGroup) {&#10;&#9;// Public with rate limiting&#10;&#9;loginLimiter := middleware.RateLimit(container.GetRedis(), 5, time.Minute, middleware.KeyByIPAndPath())&#10;&#9;refreshLimiter := middleware.RateLimit(container.GetRedis(), 20, time.Minute, middleware.KeyByIPAndPath())&#10;&#10;&#9;rg.POST(&quot;/login&quot;, loginLimiter, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, refreshLimiter, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(m.JWT))&#10;&#9;// Apply a softer per-IP limiter to all protected routes&#10;&#9;auth.Use(middleware.RateLimit(container.GetRedis(), 120, time.Minute, middleware.KeyByIP()))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/router.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/router.go" />
              <option name="originalContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// Register sets up routes and middleware on the given gin Engine for user module&#10;func Register(r *gin.Engine, userHandler *handlers.UserHandler, jwt *helpers.JWTManager) {&#10;&#9;// Public routes&#10;&#9;r.POST(&quot;/login&quot;, userHandler.Login)&#10;&#9;r.POST(&quot;/refresh&quot;, userHandler.Refresh)&#10;&#10;&#9;// Protected routes&#10;&#9;auth := r.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(jwt))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, userHandler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, userHandler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, userHandler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// Register sets up routes and middleware on the given gin Engine for user module&#10;func Register(r *gin.Engine, userHandler *handlers.UserHandler, jwt *helpers.JWTManager) {&#10;&#9;api := r.Group(&quot;/api&quot;)&#10;&#10;&#9;// Public routes&#10;&#9;api.POST(&quot;/login&quot;, userHandler.Login)&#10;&#9;api.POST(&quot;/refresh&quot;, userHandler.Refresh)&#10;&#10;&#9;// Protected routes&#10;&#9;auth := api.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(jwt))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, userHandler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, userHandler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, userHandler.UpdateProfile)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/user_module.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/user_module.go" />
              <option name="updatedContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// UserModule wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type UserModule struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func NewUserModule(h *handlers.UserHandler, jwt *helpers.JWTManager) *UserModule {&#10;&#9;return &amp;UserModule{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *UserModule) Register(rg *gin.RouterGroup) {&#10;&#9;// Public&#10;&#9;rg.POST(&quot;/login&quot;, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(m.JWT))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>