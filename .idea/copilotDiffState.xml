<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/internal/application/user/service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/application/user/service.go" />
              <option name="originalContent" value="package userapp&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;domain &quot;boilerplate-go-pgsql/internal/domain/user&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;var (&#10;&#9;ErrInvalidCredentials = errors.New(&quot;invalid credentials&quot;)&#10;&#9;ErrUserNotFound       = errors.New(&quot;user not found&quot;)&#10;)&#10;&#10;type Service struct {&#10;&#9;Repo domain.Repository&#10;&#9;JWT  *helpers.JWTManager&#10;}&#10;&#10;func NewService(repo domain.Repository, jwt *helpers.JWTManager) *Service {&#10;&#9;return &amp;Service{Repo: repo, JWT: jwt}&#10;}&#10;&#10;type LoginResponse struct {&#10;&#9;UserID string `json:&quot;user_id&quot;`&#10;&#9;Email  string `json:&quot;email&quot;`&#10;&#9;Name   string `json:&quot;name&quot;`&#10;}&#10;&#10;func (s *Service) Login(email, password string) (*LoginResponse, string, time.Time, string, time.Time, error) {&#10;&#9;u, err := s.Repo.GetByEmail(email)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;if !helpers.CompareHashAndPassword(u.Password, password) {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;return &amp;LoginResponse{UserID: u.ID, Email: u.Email, Name: u.Name}, access, aexp, refresh, rexp, nil&#10;}&#10;&#10;func (s *Service) Refresh(refreshToken string) (string, time.Time, string, time.Time, string, error) {&#10;&#9;claims, err := s.JWT.ParseRefreshToken(refreshToken)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;// ensure user still exists&#10;&#9;u, err := s.Repo.GetByID(claims.UserID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;return access, aexp, refresh, rexp, u.ID, nil&#10;}&#10;&#10;func (s *Service) GetProfile(userID string) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;type UpdateProfileInput struct {&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;}&#10;&#10;func (s *Service) UpdateProfile(userID string, in UpdateProfileInput) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;if in.Name != &quot;&quot; {&#10;&#9;&#9;u.Name = in.Name&#10;&#9;}&#10;&#9;if in.AvatarURL != &quot;&quot; {&#10;&#9;&#9;u.AvatarURL = in.AvatarURL&#10;&#9;}&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;" />
              <option name="updatedContent" value="package userapp&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;cloud.google.com/go/storage&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;domain &quot;boilerplate-go-pgsql/internal/domain/user&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;var (&#10;&#9;ErrInvalidCredentials = errors.New(&quot;invalid credentials&quot;)&#10;&#9;ErrUserNotFound       = errors.New(&quot;user not found&quot;)&#10;)&#10;&#10;type Service struct {&#10;&#9;Repo      domain.Repository&#10;&#9;JWT       *helpers.JWTManager&#10;&#9;GCS       *storage.Client&#10;&#9;GCSBucket string&#10;&#9;Redis     *redis.Client&#10;&#9;Logger    *logrus.Logger&#10;}&#10;&#10;func NewService(repo domain.Repository, jwt *helpers.JWTManager, gcs *storage.Client, gcsBucket string, rdb *redis.Client, logger *logrus.Logger) *Service {&#10;&#9;return &amp;Service{Repo: repo, JWT: jwt, GCS: gcs, GCSBucket: gcsBucket, Redis: rdb, Logger: logger}&#10;}&#10;&#10;type LoginResponse struct {&#10;&#9;UserID string `json:&quot;user_id&quot;`&#10;&#9;Email  string `json:&quot;email&quot;`&#10;&#9;Name   string `json:&quot;name&quot;`&#10;}&#10;&#10;func (s *Service) Login(email, password string) (*LoginResponse, string, time.Time, string, time.Time, error) {&#10;&#9;u, err := s.Repo.GetByEmail(email)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;if !helpers.CompareHashAndPassword(u.Password, password) {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;return &amp;LoginResponse{UserID: u.ID, Email: u.Email, Name: u.Name}, access, aexp, refresh, rexp, nil&#10;}&#10;&#10;func (s *Service) Refresh(refreshToken string) (string, time.Time, string, time.Time, string, error) {&#10;&#9;claims, err := s.JWT.ParseRefreshToken(refreshToken)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;// ensure user still exists&#10;&#9;u, err := s.Repo.GetByID(claims.UserID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;return access, aexp, refresh, rexp, u.ID, nil&#10;}&#10;&#10;func (s *Service) GetProfile(userID string) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;type UpdateProfileInput struct {&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;}&#10;&#10;func (s *Service) UpdateProfile(userID string, in UpdateProfileInput) (*domain.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;if in.Name != &quot;&quot; {&#10;&#9;&#9;u.Name = in.Name&#10;&#9;}&#10;&#9;if in.AvatarURL != &quot;&quot; {&#10;&#9;&#9;u.AvatarURL = in.AvatarURL&#10;&#9;}&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;// UploadAvatar demonstrates uploading an avatar to GCS from a reader and updating profile&#10;func (s *Service) UploadAvatar(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, ErrUserNotFound&#10;&#9;}&#10;&#9;url, err := s.uploadImageToGCS(ctx, userID, r, filename, contentType)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;u.AvatarURL = url&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;// cache meta in redis (optional)&#10;&#9;meta := map[string]any{&quot;user_id&quot;: userID, &quot;avatar_url&quot;: url, &quot;updated_at&quot;: time.Now()}&#10;&#9;_ = helpers.RedisSetJSON(ctx, s.Redis, &quot;user:avatar:&quot;+userID, meta, 24*time.Hour)&#10;&#9;return url, nil&#10;}&#10;&#10;func (s *Service) uploadImageToGCS(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;if s.GCS == nil || s.GCSBucket == &quot;&quot; {&#10;&#9;&#9;return &quot;&quot;, errors.New(&quot;gcs not configured&quot;)&#10;&#9;}&#10;&#9;id := uuid.NewString()&#10;&#9;ext := strings.ToLower(filepath.Ext(filename))&#10;&#9;objectPath := filepath.ToSlash(filepath.Join(&quot;avatars&quot;, userID, id+ext))&#10;&#9;return helpers.UploadImageToGCS(ctx, s.GCS, s.GCSBucket, objectPath, contentType, r)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/application/user_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/application/user_service.go" />
              <option name="originalContent" value="package application&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;cloud.google.com/go/storage&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;entity &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/domain/entity&quot;&#10;&#9;repo &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/domain/repository&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/pkg/helpers&quot;&#10;)&#10;&#10;var (&#10;&#9;ErrInvalidCredentials = errors.New(&quot;invalid credentials&quot;)&#10;&#9;ErrUserNotFound       = errors.New(&quot;user not found&quot;)&#10;)&#10;&#10;type Service struct {&#10;&#9;Repo      repo.UserRepository&#10;&#9;JWT       *helpers.JWTManager&#10;&#9;GCS       *storage.Client&#10;&#9;GCSBucket string&#10;&#9;Redis     *redis.Client&#10;&#9;Logger    *logrus.Logger&#10;}&#10;&#10;func NewService(repo repo.UserRepository, jwt *helpers.JWTManager, gcs *storage.Client, gcsBucket string, rdb *redis.Client, logger *logrus.Logger) *Service {&#10;&#9;return &amp;Service{Repo: repo, JWT: jwt, GCS: gcs, GCSBucket: gcsBucket, Redis: rdb, Logger: logger}&#10;}&#10;&#10;type LoginResponse struct {&#10;&#9;UserID string `json:&quot;user_id&quot;`&#10;&#9;Email  string `json:&quot;email&quot;`&#10;&#9;Name   string `json:&quot;name&quot;`&#10;}&#10;&#10;func (s *Service) Login(email, password string) (*LoginResponse, string, time.Time, string, time.Time, error) {&#10;&#9;u, err := s.Repo.GetByEmail(email)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;if !helpers.CompareHashAndPassword(u.Password, password) {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;return &amp;LoginResponse{UserID: u.ID, Email: u.Email, Name: u.Name}, access, aexp, refresh, rexp, nil&#10;}&#10;&#10;func (s *Service) Refresh(refreshToken string) (string, time.Time, string, time.Time, string, error) {&#10;&#9;claims, err := s.JWT.ParseRefreshToken(refreshToken)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;// ensure user still exists&#10;&#9;u, err := s.Repo.GetByID(claims.UserID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;return access, aexp, refresh, rexp, u.ID, nil&#10;}&#10;&#10;func (s *Service) GetProfile(userID string) (*entity.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;type UpdateProfileInput struct {&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;}&#10;&#10;func (s *Service) UpdateProfile(userID string, in UpdateProfileInput) (*entity.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;if in.Name != &quot;&quot; {&#10;&#9;&#9;u.Name = in.Name&#10;&#9;}&#10;&#9;if in.AvatarURL != &quot;&quot; {&#10;&#9;&#9;u.AvatarURL = in.AvatarURL&#10;&#9;}&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;// UploadAvatar demonstrates uploading an avatar to GCS from a reader and updating profile&#10;func (s *Service) UploadAvatar(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, ErrUserNotFound&#10;&#9;}&#10;&#9;url, err := s.uploadImageToGCS(ctx, userID, r, filename, contentType)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;u.AvatarURL = url&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;// cache meta in redis (optional)&#10;&#9;meta := map[string]any{&quot;user_id&quot;: userID, &quot;avatar_url&quot;: url, &quot;updated_at&quot;: time.Now()}&#10;&#9;_ = helpers.RedisSetJSON(ctx, s.Redis, &quot;user:avatar:&quot;+userID, meta, 24*time.Hour)&#10;&#9;return url, nil&#10;}&#10;&#10;func (s *Service) uploadImageToGCS(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;if s.GCS == nil || s.GCSBucket == &quot;&quot; {&#10;&#9;&#9;return &quot;&quot;, errors.New(&quot;gcs not configured&quot;)&#10;&#9;}&#10;&#9;id := uuid.NewString()&#10;&#9;ext := strings.ToLower(filepath.Ext(filename))&#10;&#9;objectPath := filepath.ToSlash(filepath.Join(&quot;avatars&quot;, userID, id+ext))&#10;&#9;return helpers.UploadImageToGCS(ctx, s.GCS, s.GCSBucket, objectPath, contentType, r)&#10;}&#10;" />
              <option name="updatedContent" value="package application&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;cloud.google.com/go/storage&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;entity &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/domain/entity&quot;&#10;&#9;repo &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/domain/repository&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/pkg/helpers&quot;&#10;)&#10;&#10;var (&#10;&#9;ErrInvalidCredentials = errors.New(&quot;invalid credentials&quot;)&#10;&#9;ErrUserNotFound       = errors.New(&quot;user not found&quot;)&#10;)&#10;&#10;type Service struct {&#10;&#9;Repo      repo.UserRepository&#10;&#9;JWT       *helpers.JWTManager&#10;&#9;GCS       *storage.Client&#10;&#9;GCSBucket string&#10;&#9;Redis     *redis.Client&#10;&#9;Logger    *logrus.Logger&#10;}&#10;&#10;func NewService(repo repo.UserRepository, jwt *helpers.JWTManager, gcs *storage.Client, gcsBucket string, rdb *redis.Client, logger *logrus.Logger) *Service {&#10;&#9;return &amp;Service{Repo: repo, JWT: jwt, GCS: gcs, GCSBucket: gcsBucket, Redis: rdb, Logger: logger}&#10;}&#10;&#10;type LoginResponse struct {&#10;&#9;UserID string `json:&quot;user_id&quot;`&#10;&#9;Email  string `json:&quot;email&quot;`&#10;&#9;Name   string `json:&quot;name&quot;`&#10;}&#10;&#10;func (s *Service) Login(email, password string) (*LoginResponse, string, time.Time, string, time.Time, error) {&#10;&#9;u, err := s.Repo.GetByEmail(email)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;if !helpers.CompareHashAndPassword(u.Password, password) {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;}&#10;&#10;&#9;// Store user session in Redis as a Hash and set expiration&#10;&#9;if s.Redis != nil {&#10;&#9;&#9;ctx := context.Background()&#10;&#9;&#9;key := &quot;user:session:&quot; + u.ID&#10;&#9;&#9;fields := map[string]any{&#10;&#9;&#9;&#9;&quot;user_id&quot;:    u.ID,&#10;&#9;&#9;&#9;&quot;email&quot;:      u.Email,&#10;&#9;&#9;&#9;&quot;name&quot;:       u.Name,&#10;&#9;&#9;&#9;&quot;avatar_url&quot;: u.AvatarURL,&#10;&#9;&#9;&#9;&quot;logged_in&quot;:  true,&#10;&#9;&#9;&#9;&quot;created_at&quot;: time.Now().String(),&#10;&#9;&#9;}&#10;&#9;&#9;if err := s.Redis.HSet(ctx, key, fields).Err(); err != nil {&#10;&#9;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;&#9;}&#10;&#9;&#9;if err := s.Redis.Expire(ctx, key, 24*time.Hour).Err(); err != nil {&#10;&#9;&#9;&#9;return nil, &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return &amp;LoginResponse{UserID: u.ID, Email: u.Email, Name: u.Name}, access, aexp, refresh, rexp, nil&#10;}&#10;&#10;func (s *Service) Refresh(refreshToken string) (string, time.Time, string, time.Time, string, error) {&#10;&#9;claims, err := s.JWT.ParseRefreshToken(refreshToken)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;// ensure user still exists&#10;&#9;u, err := s.Repo.GetByID(claims.UserID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, ErrInvalidCredentials&#10;&#9;}&#10;&#9;access, aexp, err := s.JWT.GenerateAccessToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;refresh, rexp, err := s.JWT.GenerateRefreshToken(u.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, time.Time{}, &quot;&quot;, time.Time{}, &quot;&quot;, err&#10;&#9;}&#10;&#9;return access, aexp, refresh, rexp, u.ID, nil&#10;}&#10;&#10;func (s *Service) GetProfile(userID string) (*entity.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;type UpdateProfileInput struct {&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;}&#10;&#10;func (s *Service) UpdateProfile(userID string, in UpdateProfileInput) (*entity.User, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return nil, ErrUserNotFound&#10;&#9;}&#10;&#9;if in.Name != &quot;&quot; {&#10;&#9;&#9;u.Name = in.Name&#10;&#9;}&#10;&#9;if in.AvatarURL != &quot;&quot; {&#10;&#9;&#9;u.AvatarURL = in.AvatarURL&#10;&#9;}&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return u, nil&#10;}&#10;&#10;// UploadAvatar demonstrates uploading an avatar to GCS from a reader and updating profile&#10;func (s *Service) UploadAvatar(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;u, err := s.Repo.GetByID(userID)&#10;&#9;if err != nil || u == nil {&#10;&#9;&#9;return &quot;&quot;, ErrUserNotFound&#10;&#9;}&#10;&#9;url, err := s.uploadImageToGCS(ctx, userID, r, filename, contentType)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;u.AvatarURL = url&#10;&#9;if err := s.Repo.Update(u); err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;// cache meta in redis (optional)&#10;&#9;meta := map[string]any{&quot;user_id&quot;: userID, &quot;avatar_url&quot;: url, &quot;updated_at&quot;: time.Now()}&#10;&#9;_ = helpers.RedisSetJSON(ctx, s.Redis, &quot;user:avatar:&quot;+userID, meta, 24*time.Hour)&#10;&#9;return url, nil&#10;}&#10;&#10;func (s *Service) uploadImageToGCS(ctx context.Context, userID string, r io.Reader, filename, contentType string) (string, error) {&#10;&#9;if s.GCS == nil || s.GCSBucket == &quot;&quot; {&#10;&#9;&#9;return &quot;&quot;, errors.New(&quot;gcs not configured&quot;)&#10;&#9;}&#10;&#9;id := uuid.NewString()&#10;&#9;ext := strings.ToLower(filepath.Ext(filename))&#10;&#9;objectPath := filepath.ToSlash(filepath.Join(&quot;avatars&quot;, userID, id+ext))&#10;&#9;return helpers.UploadImageToGCS(ctx, s.GCS, s.GCSBucket, objectPath, contentType, r)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/domain/user/entity.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/domain/user/entity.go" />
              <option name="originalContent" value="package user&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// User is the aggregate root for user domain&#10;// Passwords are stored as bcrypt hashes&#10;//&#10;// In a real-world app, prefer value objects for Email, etc.&#10;type User struct {&#10;&#9;ID           string&#10;&#9;Email        string&#10;&#9;PasswordHash string&#10;&#9;Name         string&#10;&#9;AvatarURL    string&#10;&#9;CreatedAt    time.Time&#10;&#9;UpdatedAt    time.Time&#10;}&#10;" />
              <option name="updatedContent" value="package user&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// User is the aggregate root for user domain&#10;// Passwords are stored as bcrypt hashes in Password field&#10;//&#10;// In a real-world app, prefer value objects for Email, etc.&#10;type User struct {&#10;&#9;ID        string&#10;&#9;Email     string&#10;&#9;Password  string&#10;&#9;Name      string&#10;&#9;AvatarURL string&#10;&#9;CreatedAt time.Time&#10;&#9;UpdatedAt time.Time&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/domain/user/repository.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/domain/user/repository.go" />
              <option name="updatedContent" value="package user&#10;&#10;// Repository abstracts persistence for User aggregate&#10;// This lives in the domain layer to decouple application/business logic from infrastructure.&#10;type Repository interface {&#10;&#9;Create(u *User) error&#10;&#9;GetByID(id string) (*User, error)&#10;&#9;GetByEmail(email string) (*User, error)&#10;&#9;Update(u *User) error&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/interface/http/image_handler.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/interface/http/image_handler.go" />
              <option name="updatedContent" value="package handlers&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;mime/multipart&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;cloud.google.com/go/storage&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;type ImageHandler struct {&#10;&#9;GCS    *storage.Client&#10;&#9;Bucket string&#10;&#9;Redis  *redis.Client&#10;&#9;Logger *logrus.Logger&#10;}&#10;&#10;func NewImageHandler(gcs *storage.Client, bucket string, rdb *redis.Client, logger *logrus.Logger) *ImageHandler {&#10;&#9;return &amp;ImageHandler{GCS: gcs, Bucket: bucket, Redis: rdb, Logger: logger}&#10;}&#10;&#10;type ImageMeta struct {&#10;&#9;ID          string    `json:&quot;id&quot;`&#10;&#9;URL         string    `json:&quot;url&quot;`&#10;&#9;ContentType string    `json:&quot;content_type&quot;`&#10;&#9;UploaderID  string    `json:&quot;uploader_id&quot;`&#10;&#9;CreatedAt   time.Time `json:&quot;created_at&quot;`&#10;}&#10;&#10;func (h *ImageHandler) Upload(c *gin.Context) {&#10;&#9;uid := c.GetString(&quot;userID&quot;)&#10;&#9;file, header, err := c.Request.FormFile(&quot;file&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusBadRequest, &quot;file is required&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer file.Close()&#10;&#10;&#9;contentType := sniffContentType(header)&#10;&#9;id := uuid.NewString()&#10;&#9;ext := strings.ToLower(filepath.Ext(header.Filename))&#10;&#9;objectPath := fmt.Sprintf(&quot;uploads/%s/%s%s&quot;, uid, id, ext)&#10;&#10;&#9;url, err := helpers.UploadObject(c.Request.Context(), h.GCS, h.Bucket, objectPath, contentType, file)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusInternalServerError, &quot;upload failed&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;meta := &amp;ImageMeta{ID: id, URL: url, ContentType: contentType, UploaderID: uid, CreatedAt: time.Now()}&#10;&#9;_ = helpers.RedisSetJSON(c.Request.Context(), h.Redis, imageKey(id), meta, 24*time.Hour)&#10;&#9;c.JSON(http.StatusOK, helpers.APIResponse(meta, &quot;uploaded&quot;))&#10;}&#10;&#10;func (h *ImageHandler) Get(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var meta ImageMeta&#10;&#9;found, err := helpers.RedisGetJSON(c.Request.Context(), h.Redis, imageKey(id), &amp;meta)&#10;&#9;if err != nil {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusInternalServerError, &quot;cache error&quot;, err.Error())&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;if !found {&#10;&#9;&#9;status, resp := helpers.APIError(http.StatusNotFound, &quot;image not found&quot;, nil)&#10;&#9;&#9;c.JSON(status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;c.JSON(http.StatusOK, helpers.APIResponse(meta, &quot;ok&quot;))&#10;}&#10;&#10;func sniffContentType(h *multipart.FileHeader) string {&#10;&#9;if h.Header.Get(&quot;Content-Type&quot;) != &quot;&quot; {&#10;&#9;&#9;return h.Header.Get(&quot;Content-Type&quot;)&#10;&#9;}&#10;&#9;return &quot;application/octet-stream&quot;&#10;}&#10;&#10;func imageKey(id string) string { return &quot;image:&quot; + id }&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/interface/http/user_handler.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/interface/http/user_handler.go" />
              <option name="originalContent" value="package handlers&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;userapp &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/application&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/pkg/helpers&quot;&#10;)&#10;&#10;type UserHandler struct {&#10;&#9;Svc    *userapp.Service&#10;&#9;JWT    *helpers.JWTManager&#10;&#9;Logger *logrus.Logger&#10;&#10;&#9;CookieDomain string&#10;&#9;CookieSecure bool&#10;}&#10;&#10;func NewUserHandler(svc *userapp.Service, jwt *helpers.JWTManager, logger *logrus.Logger, cookieDomain string, cookieSecure bool) *UserHandler {&#10;&#9;return &amp;UserHandler{Svc: svc, JWT: jwt, Logger: logger, CookieDomain: cookieDomain, CookieSecure: cookieSecure}&#10;}&#10;&#10;type loginRequest struct {&#10;&#9;Email    string `json:&quot;email&quot;`&#10;&#9;Password string `json:&quot;password&quot;`&#10;}&#10;&#10;type updateProfileRequest struct {&#10;&#9;Name      string `json:&quot;name&quot;`&#10;&#9;AvatarURL string `json:&quot;avatar_url&quot;`&#10;}&#10;&#10;func (h *UserHandler) Login(c *gin.Context) {&#10;&#9;var req loginRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil || req.Email == &quot;&quot; || req.Password == &quot;&quot; {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusBadRequest, &quot;invalid payload&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;res, access, aexp, refresh, rexp, err := h.Svc.Login(req.Email, req.Password)&#10;&#9;if err != nil {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusUnauthorized, &quot;invalid credentials&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;setAuthCookies(c, access, aexp, refresh, rexp, h.CookieDomain, h.CookieSecure)&#10;&#9;resp := helpers.Success(c, http.StatusOK, res, &quot;login successful&quot;, map[string]any{&quot;access_expires_at&quot;: aexp, &quot;refresh_expires_at&quot;: rexp})&#10;&#9;c.JSON(resp.Status, resp)&#10;}&#10;&#10;func (h *UserHandler) Refresh(c *gin.Context) {&#10;&#9;refresh, err := c.Cookie(&quot;refresh_token&quot;)&#10;&#9;if err != nil || refresh == &quot;&quot; {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusUnauthorized, &quot;missing refresh token&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;access, aexp, newRefresh, rexp, _, err := h.Svc.Refresh(refresh)&#10;&#9;if err != nil {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusUnauthorized, &quot;invalid refresh token&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;setAuthCookies(c, access, aexp, newRefresh, rexp, h.CookieDomain, h.CookieSecure)&#10;&#9;resp := helpers.Success[any](c, http.StatusOK, map[string]any{&quot;refreshed&quot;: true}, &quot;token refreshed&quot;, map[string]any{&quot;access_expires_at&quot;: aexp, &quot;refresh_expires_at&quot;: rexp})&#10;&#9;c.JSON(resp.Status, resp)&#10;}&#10;&#10;func (h *UserHandler) Logout(c *gin.Context) {&#10;&#9;clearAuthCookies(c, h.CookieDomain, h.CookieSecure)&#10;&#9;resp := helpers.Success[any](c, http.StatusOK, map[string]any{&quot;logged_out&quot;: true}, &quot;logged out&quot;, nil)&#10;&#9;c.JSON(resp.Status, resp)&#10;}&#10;&#10;func (h *UserHandler) GetProfile(c *gin.Context) {&#10;&#9;uid := c.GetString(&quot;userID&quot;)&#10;&#9;u, err := h.Svc.GetProfile(uid)&#10;&#9;if err != nil {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusNotFound, &quot;user not found&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;resp := helpers.Success(c, http.StatusOK, gin.H{&#10;&#9;&#9;&quot;id&quot;:         u.ID,&#10;&#9;&#9;&quot;email&quot;:      u.Email,&#10;&#9;&#9;&quot;name&quot;:       u.Name,&#10;&#9;&#9;&quot;avatar_url&quot;: u.AvatarURL,&#10;&#9;&#9;&quot;created_at&quot;: u.CreatedAt,&#10;&#9;&#9;&quot;updated_at&quot;: u.UpdatedAt,&#10;&#9;}, &quot;profile&quot;, nil)&#10;&#9;c.JSON(resp.Status, resp)&#10;}&#10;&#10;func (h *UserHandler) UpdateProfile(c *gin.Context) {&#10;&#9;uid := c.GetString(&quot;userID&quot;)&#10;&#9;var req updateProfileRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusBadRequest, &quot;invalid payload&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;u, err := h.Svc.UpdateProfile(uid, userapp.UpdateProfileInput{Name: req.Name, AvatarURL: req.AvatarURL})&#10;&#9;if err != nil {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusBadRequest, &quot;failed to update profile&quot;, err.Error())&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;resp := helpers.Success(c, http.StatusOK, gin.H{&#10;&#9;&#9;&quot;id&quot;:         u.ID,&#10;&#9;&#9;&quot;email&quot;:      u.Email,&#10;&#9;&#9;&quot;name&quot;:       u.Name,&#10;&#9;&#9;&quot;avatar_url&quot;: u.AvatarURL,&#10;&#9;&#9;&quot;created_at&quot;: u.CreatedAt,&#10;&#9;&#9;&quot;updated_at&quot;: u.UpdatedAt,&#10;&#9;}, &quot;profile updated&quot;, nil)&#10;&#9;c.JSON(resp.Status, resp)&#10;}&#10;&#10;func setAuthCookies(c *gin.Context, access string, aexp time.Time, refresh string, rexp time.Time, domain string, secure bool) {&#10;&#9;c.SetSameSite(http.SameSiteLaxMode)&#10;&#9;// MaxAge in seconds&#10;&#9;aMax := int(time.Until(aexp).Seconds())&#10;&#9;rMax := int(time.Until(rexp).Seconds())&#10;&#9;c.SetCookie(&quot;access_token&quot;, access, aMax, &quot;/&quot;, domain, secure, true)&#10;&#9;c.SetCookie(&quot;refresh_token&quot;, refresh, rMax, &quot;/&quot;, domain, secure, true)&#10;}&#10;&#10;func clearAuthCookies(c *gin.Context, domain string, secure bool) {&#10;&#9;c.SetSameSite(http.SameSiteLaxMode)&#10;&#9;c.SetCookie(&quot;access_token&quot;, &quot;&quot;, -1, &quot;/&quot;, domain, secure, true)&#10;&#9;c.SetCookie(&quot;refresh_token&quot;, &quot;&quot;, -1, &quot;/&quot;, domain, secure, true)&#10;}&#10;" />
              <option name="updatedContent" value="package handlers&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#10;&#9;userapp &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/application&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/pkg/helpers&quot;&#10;)&#10;&#10;type UserHandler struct {&#10;&#9;Svc    *userapp.Service&#10;&#9;JWT    *helpers.JWTManager&#10;&#9;Logger *logrus.Logger&#10;&#10;&#9;CookieDomain string&#10;&#9;CookieSecure bool&#10;}&#10;&#10;func NewUserHandler(svc *userapp.Service, jwt *helpers.JWTManager, logger *logrus.Logger, cookieDomain string, cookieSecure bool) *UserHandler {&#10;&#9;return &amp;UserHandler{Svc: svc, JWT: jwt, Logger: logger, CookieDomain: cookieDomain, CookieSecure: cookieSecure}&#10;}&#10;&#10;type loginRequest struct {&#10;&#9;Email    string `json:&quot;email&quot;`&#10;&#9;Password string `json:&quot;password&quot;`&#10;}&#10;&#10;type updateProfileRequest struct {&#10;&#9;Name      string `json:&quot;name&quot;`&#10;&#9;AvatarURL string `json:&quot;avatar_url&quot;`&#10;}&#10;&#10;func (h *UserHandler) Login(c *gin.Context) {&#10;&#9;var req loginRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil || req.Email == &quot;&quot; || req.Password == &quot;&quot; {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusBadRequest, &quot;invalid payload&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;res, pair, err := h.Svc.Login(c.Request.Context(), req.Email, req.Password)&#10;&#9;if err != nil {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusUnauthorized, &quot;invalid credentials&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;setAuthCookies(c, pair.AccessToken, pair.AccessTokenExpiry, pair.RefreshToken, pair.RefreshTokenExpiry, h.CookieDomain, h.CookieSecure)&#10;&#9;resp := helpers.Success(c, http.StatusOK, res, &quot;login successful&quot;, map[string]any{&quot;access_expires_at&quot;: pair.AccessTokenExpiry, &quot;refresh_expires_at&quot;: pair.RefreshTokenExpiry})&#10;&#9;c.JSON(resp.Status, resp)&#10;}&#10;&#10;func (h *UserHandler) Refresh(c *gin.Context) {&#10;&#9;refresh, err := c.Cookie(&quot;refresh_token&quot;)&#10;&#9;if err != nil || refresh == &quot;&quot; {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusUnauthorized, &quot;missing refresh token&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;pair, _, err := h.Svc.Refresh(c.Request.Context(), refresh)&#10;&#9;if err != nil {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusUnauthorized, &quot;invalid refresh token&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;setAuthCookies(c, pair.AccessToken, pair.AccessTokenExpiry, pair.RefreshToken, pair.RefreshTokenExpiry, h.CookieDomain, h.CookieSecure)&#10;&#9;resp := helpers.Success[any](c, http.StatusOK, map[string]any{&quot;refreshed&quot;: true}, &quot;token refreshed&quot;, map[string]any{&quot;access_expires_at&quot;: pair.AccessTokenExpiry, &quot;refresh_expires_at&quot;: pair.RefreshTokenExpiry})&#10;&#9;c.JSON(resp.Status, resp)&#10;}&#10;&#10;func (h *UserHandler) Logout(c *gin.Context) {&#10;&#9;clearAuthCookies(c, h.CookieDomain, h.CookieSecure)&#10;&#9;resp := helpers.Success[any](c, http.StatusOK, map[string]any{&quot;logged_out&quot;: true}, &quot;logged out&quot;, nil)&#10;&#9;c.JSON(resp.Status, resp)&#10;}&#10;&#10;func (h *UserHandler) GetProfile(c *gin.Context) {&#10;&#9;uid := c.GetString(&quot;userID&quot;)&#10;&#9;u, err := h.Svc.GetProfile(uid)&#10;&#9;if err != nil {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusNotFound, &quot;user not found&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;resp := helpers.Success(c, http.StatusOK, gin.H{&#10;&#9;&#9;&quot;id&quot;:         u.ID,&#10;&#9;&#9;&quot;email&quot;:      u.Email,&#10;&#9;&#9;&quot;name&quot;:       u.Name,&#10;&#9;&#9;&quot;avatar_url&quot;: u.AvatarURL,&#10;&#9;&#9;&quot;created_at&quot;: u.CreatedAt,&#10;&#9;&#9;&quot;updated_at&quot;: u.UpdatedAt,&#10;&#9;}, &quot;profile&quot;, nil)&#10;&#9;c.JSON(resp.Status, resp)&#10;}&#10;&#10;func (h *UserHandler) UpdateProfile(c *gin.Context) {&#10;&#9;uid := c.GetString(&quot;userID&quot;)&#10;&#9;var req updateProfileRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusBadRequest, &quot;invalid payload&quot;, nil)&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;u, err := h.Svc.UpdateProfile(c.Request.Context(), uid, userapp.UpdateProfileInput{Name: req.Name, AvatarURL: req.AvatarURL})&#10;&#9;if err != nil {&#10;&#9;&#9;resp := helpers.Error[any](c, http.StatusBadRequest, &quot;failed to update profile&quot;, err.Error())&#10;&#9;&#9;c.JSON(resp.Status, resp)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;resp := helpers.Success(c, http.StatusOK, gin.H{&#10;&#9;&#9;&quot;id&quot;:         u.ID,&#10;&#9;&#9;&quot;email&quot;:      u.Email,&#10;&#9;&#9;&quot;name&quot;:       u.Name,&#10;&#9;&#9;&quot;avatar_url&quot;: u.AvatarURL,&#10;&#9;&#9;&quot;created_at&quot;: u.CreatedAt,&#10;&#9;&#9;&quot;updated_at&quot;: u.UpdatedAt,&#10;&#9;}, &quot;profile updated&quot;, nil)&#10;&#9;c.JSON(resp.Status, resp)&#10;}&#10;&#10;func setAuthCookies(c *gin.Context, access string, aexp time.Time, refresh string, rexp time.Time, domain string, secure bool) {&#10;&#9;c.SetSameSite(http.SameSiteLaxMode)&#10;&#9;// MaxAge in seconds&#10;&#9;aMax := int(time.Until(aexp).Seconds())&#10;&#9;rMax := int(time.Until(rexp).Seconds())&#10;&#9;c.SetCookie(&quot;access_token&quot;, access, aMax, &quot;/&quot;, domain, secure, true)&#10;&#9;c.SetCookie(&quot;refresh_token&quot;, refresh, rMax, &quot;/&quot;, domain, secure, true)&#10;}&#10;&#10;func clearAuthCookies(c *gin.Context, domain string, secure bool) {&#10;&#9;c.SetSameSite(http.SameSiteLaxMode)&#10;&#9;c.SetCookie(&quot;access_token&quot;, &quot;&quot;, -1, &quot;/&quot;, domain, secure, true)&#10;&#9;c.SetCookie(&quot;refresh_token&quot;, &quot;&quot;, -1, &quot;/&quot;, domain, secure, true)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/interface/middleware/auth.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/interface/middleware/auth.go" />
              <option name="updatedContent" value="package middleware&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/redis/go-redis/v9&quot;&#10;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/pkg/helpers&quot;&#10;)&#10;&#10;// Auth validates access token and ensures an active session exists in Redis.&#10;// It sets userID, userName, and userEmail in the Gin context on success.&#10;func Auth(rdb *redis.Client, jwt *helpers.JWTManager) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;token, err := c.Cookie(&quot;access_token&quot;)&#10;&#9;&#9;if err != nil || token == &quot;&quot; {&#10;&#9;&#9;&#9;resp := helpers.Error[any](c, http.StatusUnauthorized, &quot;missing access token&quot;, nil)&#10;&#9;&#9;&#9;c.AbortWithStatusJSON(resp.Status, resp)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;claims, err := jwt.ParseAccessToken(token)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;resp := helpers.Error[any](c, http.StatusUnauthorized, &quot;invalid access token&quot;, err.Error())&#10;&#9;&#9;&#9;c.AbortWithStatusJSON(resp.Status, resp)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Retrieve session from Redis as a hash&#10;&#9;&#9;key := &quot;user:session:&quot; + claims.UserID&#10;&#9;&#9;data, err := rdb.HGetAll(c.Request.Context(), key).Result()&#10;&#9;&#9;if err != nil || len(data) == 0 {&#10;&#9;&#9;&#9;resp := helpers.Error[any](c, http.StatusUnauthorized, &quot;session not found&quot;, nil)&#10;&#9;&#9;&#9;c.AbortWithStatusJSON(resp.Status, resp)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Set(&quot;userID&quot;, data[&quot;user_id&quot;]) // required by handlers&#10;&#9;&#9;c.Set(&quot;userName&quot;, data[&quot;name&quot;])  // extra convenience&#10;&#9;&#9;c.Set(&quot;userEmail&quot;, data[&quot;email&quot;]) // extra convenience&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/contracts/contracts.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/contracts/contracts.go" />
              <option name="updatedContent" value="package contracts&#10;&#10;import &quot;github.com/gin-gonic/gin&quot;&#10;&#10;// Module describes a feature module that can register its routes on a RouterGroup&#10;// Example: a User module, Product module, etc.&#10;type Module interface {&#10;&#9;Register(rg *gin.RouterGroup)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/modules/builder.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/modules/builder.go" />
              <option name="updatedContent" value="package modules&#10;&#10;import (&#10;&#9;&quot;boilerplate-go-pgsql/internal/container&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/router/contracts&quot;&#10;&#9;usermodule &quot;boilerplate-go-pgsql/internal/router/modules/user&quot;&#10;&#10;&#9;// construction deps&#10;&#9;appuser &quot;boilerplate-go-pgsql/internal/application/user&quot;&#10;&#9;pginfra &quot;boilerplate-go-pgsql/internal/infrastructure/postgres&quot;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;)&#10;&#10;// BuildAll discovers and builds all available modules from container singletons&#10;// Add new modules here in the future to keep registry clean.&#10;func BuildAll() []contracts.Module {&#10;&#9;mods := make([]contracts.Module, 0, 4)&#10;&#10;&#9;// User module&#10;&#9;if m := buildUserModule(); m != nil {&#10;&#9;&#9;mods = append(mods, m)&#10;&#9;}&#10;&#10;&#9;return mods&#10;}&#10;&#10;func buildUserModule() contracts.Module {&#10;&#9;h := container.GetUserHandler()&#10;&#9;if h == nil {&#10;&#9;&#9;pool := container.GetPGPool()&#10;&#9;&#9;jwt := container.GetJWT()&#10;&#9;&#9;cfg := container.GetConfig()&#10;&#9;&#9;gcs := container.GetGCS()&#10;&#9;&#9;rdb := container.GetRedis()&#10;&#9;&#9;logger := container.GetLogger()&#10;&#9;&#9;if pool != nil &amp;&amp; jwt != nil &amp;&amp; cfg != nil &amp;&amp; logger != nil {&#10;&#9;&#9;&#9;repo := pginfra.NewUserRepository(pool)&#10;&#9;&#9;&#9;svc := appuser.NewService(repo, jwt, gcs, cfg.GCSBucket, rdb, logger)&#10;&#9;&#9;&#9;h = handlers.NewUserHandler(svc, jwt, logger, cfg.CookieDomain, cfg.CookieSecure)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;if h == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;jwt := container.GetJWT()&#10;&#9;return usermodule.New(h, jwt)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/modules/user/module.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/modules/user/module.go" />
              <option name="originalContent" value="package user&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/container&quot;&#10;&#10;&#9;handlers &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/interface/http&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/interface/middleware&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/pkg/helpers&quot;&#10;)&#10;&#10;// Module wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type Module struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func New(h *handlers.UserHandler, jwt *helpers.JWTManager) *Module {&#10;&#9;return &amp;Module{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *Module) Register(rg *gin.RouterGroup) {&#10;&#9;// Public with rate limiting&#10;&#9;loginLimiter := middleware.RateLimit(container.GetRedis(), 5, time.Minute, middleware.KeyByIPAndPath())&#10;&#9;refreshLimiter := middleware.RateLimit(container.GetRedis(), 20, time.Minute, middleware.KeyByIPAndPath())&#10;&#10;&#9;rg.POST(&quot;/login&quot;, loginLimiter, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, refreshLimiter, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(m.JWT))&#10;&#9;// Apply a softer per-IP limiter to all protected routes&#10;&#9;auth.Use(middleware.RateLimit(container.GetRedis(), 120, time.Minute, middleware.KeyByIP()))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package user&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/container&quot;&#10;&#10;&#9;handlers &quot;github.com/oksasatya/go-ddd-clean-architecture/internal/interface/http&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/internal/interface/middleware&quot;&#10;&#9;&quot;github.com/oksasatya/go-ddd-clean-architecture/pkg/helpers&quot;&#10;)&#10;&#10;// Module wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type Module struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func New(h *handlers.UserHandler, jwt *helpers.JWTManager) *Module {&#10;&#9;return &amp;Module{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *Module) Register(rg *gin.RouterGroup) {&#10;&#9;// Public with rate limiting&#10;&#9;loginLimiter := middleware.RateLimit(container.GetRedis(), 5, time.Minute, middleware.KeyByIPAndPath())&#10;&#9;refreshLimiter := middleware.RateLimit(container.GetRedis(), 20, time.Minute, middleware.KeyByIPAndPath())&#10;&#10;&#9;rg.POST(&quot;/login&quot;, loginLimiter, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, refreshLimiter, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.Auth(container.GetRedis(), m.JWT))&#10;&#9;// Apply a softer per-IP limiter to all protected routes&#10;&#9;auth.Use(middleware.RateLimit(container.GetRedis(), 120, time.Minute, middleware.KeyByIP()))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/router.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/router.go" />
              <option name="originalContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// Register sets up routes and middleware on the given gin Engine for user module&#10;func Register(r *gin.Engine, userHandler *handlers.UserHandler, jwt *helpers.JWTManager) {&#10;&#9;// Public routes&#10;&#9;r.POST(&quot;/login&quot;, userHandler.Login)&#10;&#9;r.POST(&quot;/refresh&quot;, userHandler.Refresh)&#10;&#10;&#9;// Protected routes&#10;&#9;auth := r.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(jwt))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, userHandler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, userHandler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, userHandler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// Register sets up routes and middleware on the given gin Engine for user module&#10;func Register(r *gin.Engine, userHandler *handlers.UserHandler, jwt *helpers.JWTManager) {&#10;&#9;api := r.Group(&quot;/api&quot;)&#10;&#10;&#9;// Public routes&#10;&#9;api.POST(&quot;/login&quot;, userHandler.Login)&#10;&#9;api.POST(&quot;/refresh&quot;, userHandler.Refresh)&#10;&#10;&#9;// Protected routes&#10;&#9;auth := api.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(jwt))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, userHandler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, userHandler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, userHandler.UpdateProfile)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/user_module.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/user_module.go" />
              <option name="updatedContent" value="package router&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#10;&#9;handlers &quot;boilerplate-go-pgsql/internal/interface/http&quot;&#10;&#9;&quot;boilerplate-go-pgsql/internal/interface/middleware&quot;&#10;&#9;&quot;boilerplate-go-pgsql/pkg/helpers&quot;&#10;)&#10;&#10;// UserModule wires user HTTP handlers and JWT middleware into routes&#10;// Public: POST /api/login, POST /api/refresh&#10;// Protected: POST /api/logout, GET /api/profile, PUT /api/profile&#10;// All routes are registered under the given RouterGroup (usually /api)&#10;&#10;type UserModule struct {&#10;&#9;Handler *handlers.UserHandler&#10;&#9;JWT     *helpers.JWTManager&#10;}&#10;&#10;func NewUserModule(h *handlers.UserHandler, jwt *helpers.JWTManager) *UserModule {&#10;&#9;return &amp;UserModule{Handler: h, JWT: jwt}&#10;}&#10;&#10;func (m *UserModule) Register(rg *gin.RouterGroup) {&#10;&#9;// Public&#10;&#9;rg.POST(&quot;/login&quot;, m.Handler.Login)&#10;&#9;rg.POST(&quot;/refresh&quot;, m.Handler.Refresh)&#10;&#10;&#9;// Protected&#10;&#9;auth := rg.Group(&quot;/&quot;)&#10;&#9;auth.Use(middleware.JWTAuth(m.JWT))&#10;&#9;{&#10;&#9;&#9;auth.POST(&quot;/logout&quot;, m.Handler.Logout)&#10;&#9;&#9;auth.GET(&quot;/profile&quot;, m.Handler.GetProfile)&#10;&#9;&#9;auth.PUT(&quot;/profile&quot;, m.Handler.UpdateProfile)&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>